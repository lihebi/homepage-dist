<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bisp</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/home/hebi/git/homepage/assets/org.css" /><link rel="stylesheet" type="text/css" href="/home/hebi/git/homepage/assets/hebi.css" /><link rel="stylesheet" type="text/css" href="/assets/org.css" /><link rel="stylesheet" type="text/css" href="/assets/hebi.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">Bisp</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbb74c9d">1. Zen</a>
<ul>
<li><a href="#org229b028">1.1. The essense of programming</a></li>
<li><a href="#orgb4c6247">1.2. Rationale</a></li>
<li><a href="#org68d9f4e">1.3. Implementation</a>
<ul>
<li><a href="#org1c2ee91">1.3.1. UPDATE 1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbe1320a">2. The Language</a>
<ul>
<li><a href="#orgf2b434b">2.1. Field Accessing with Dot-Notation</a></li>
<li><a href="#org0aaaf31">2.2. Multi-Dimensional Array: Indexing and Slicing</a></li>
<li><a href="#org8dca38f">2.3. Optional Inline Type Annotation</a></li>
<li><a href="#orgb4654be">2.4. Multi-Dispatch Generic Functions by Default</a></li>
<li><a href="#org8913a01">2.5. function defs, default and keyword arguments</a></li>
</ul>
</li>
</ul>
</div>
</div>
<blockquote>
<p>
Bisp is a typed lisp, with a little less parenthesis, infix/postfix-notation
when it makes sense, Julia-like optional static typing and multi-dispatching.
</p>
</blockquote>

<div id="outline-container-orgbb74c9d" class="outline-2">
<h2 id="orgbb74c9d"><span class="section-number-2">1</span> Zen</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org229b028" class="outline-3">
<h3 id="org229b028"><span class="section-number-3">1.1</span> The essense of programming</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The most important 4 aspects of programming in my opinion are:
</p>
<ol class="org-ol">
<li>awareness of purely functional programming, i.e. write side effect free
functions</li>
<li>interactive development driven by REPL</li>
<li>multiple dispatch. The gradual typing is useful for annotation purpose as
well as enabling multiple dispatching, and typing should be annotated
natually, right after the variable and inside function def (instead of before
as in typed racket)</li>
<li>syntactic abstraction in the form of DSLs. The zen of Python states that
there should be one way to do one thing, the obvious way. Well, that way is
the best language for the domain, which is not very obvious to support in Python.</li>
</ol>

<p>
I didn't write serious Haskell and OCaml, but I did not find that sophisticated
typing very necessary, and Monads and Lazyness did not manifest loud enough to me.
</p>

<p>
1 and 2 are operational techniques, while 3 and 4 are features of
language. Although almost all new languages provide meta-programming (the basic
of syntactic abstraction) of varing levels, racket provides the most
comprehensive syntactic abstraction toolkit, far beyond all others, and I think
it is not very possible to achieve the same level of support on non-lispy
languages. E.g. it is not very natural to create DSLs using Julia.
</p>

<p>
However, racket does not have proper and natural multiple dispatch. The
Haskell-style typing annotation in <a href="https://docs.racket-lang.org/ts-reference/index.html">typed racket</a> is not as natural, the typing
did not appear at the best location. The <a href="https://docs.racket-lang.org/reference/struct-generics.html">racket/generics</a> library provides single
dispatch, and the usage is quite cumbersome: users should just define the
function without worrying about the gen:XXX interface and fallback
implementation staff. The <a href="https://docs.racket-lang.org/multimethod/index.html">multimethod</a> package has multiple dispatch. However,
the typing annotation is even weirder, and there's no proper typing system and
dispatching strategy in this little package.
</p>

<p>
Modern languages all have a proper module system. However, all languages are
based on files, except the <a href="https://www.unisonweb.org/">unison</a> language. But the hash is not too useful other
than the fact that the renaming is painless. OK, back to the module and file, my
core idea is that there should not be file at all! And making the module and
file system collaborate is most likely the most confusing thing in a language's
module system. In BISP, you just write function defs under some module
namespace. One of the reason for uisng a file system was that Unix has it, and
there's only one way to write code: to open a file in an (CMD-based) text
editor. BISP will provide some better way to write your program, a visual way
with some features such as proper server/client separation. Another issue is
that inside a file, existing languages typically do not distinguish internal
functions and external APIs very well. Not to say that I want a system that have
(HEBI: internal helper functions and APIs at arbitrary granularity).
</p>

<p>
One more thing, I would love to use BISP on microcontrollers too. This would
require some thinking regarding racket's backend to satisfy the small memory
footprint as well as a proper and native REPL and front-end interface, the bisp
notebook maybe?. Besides microcontrollers, I would want to extend the usage
landscape to all low-level scenarios, e.g. the once used to be C, to remove the
\#ifdefs (i.e. ir-elegant machine-dependence check) and \#defines
(i.e. macros-done-wrong).
</p>

<p>
If everything goes well, I should provide a (HEBI: serverless cloud computing
infra)! To abstract over the OS/VM/container and language runtime.
</p>
</div>
</div>


<div id="outline-container-orgb4c6247" class="outline-3">
<h3 id="orgb4c6247"><span class="section-number-3">1.2</span> Rationale</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Parenthesis is a good thing, as always, because:
</p>
<ul class="org-ul">
<li>easy to parse, thus easy for syntax extension</li>
<li>unambiguous</li>
<li>structural editing</li>
</ul>

<p>
However, too much parenthesis creates readability problem, less elegent than
Haskell, OCaml and Julia.
</p>

<p>
And due to insisting on parenthesis, some intuitive syntax becomes cubersome:
</p>
<ul class="org-ul">
<li><b>struct field accessing</b>, the dot-notation, is missing</li>
<li>hard to do <b>array indexing and slicing</b>, e.g. arr[3,0:7,:]</li>
</ul>

<p>
Lisp sytems traditionally use dynamic typing. But static typing can be very
useful annotations for programming in general. It is hard to add <b>inline type
annotations</b> elegently due that additional parenthesis must be created for
grouping purpose.  Prior art: typed racket, contracts, clojure specs.
</p>

<p>
Lisp dialects also fall short on <b>multi-dispatch generic functions</b>,
i.e. functions can be dispatched based on type and number of its arguments. This
matters a lot to save the namespace of functions, and makes the program elegent
and extensible. Although racket and gerbil have generic methods, clojure has
<code>defmulti</code>, the support not as great as those in Julia.
</p>

<p>
Bisp is designed to maintain the good part of lisp, while overcoming the
afore-mentioned cons.
</p>
</div>
</div>


<div id="outline-container-org68d9f4e" class="outline-3">
<h3 id="org68d9f4e"><span class="section-number-3">1.3</span> Implementation</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The semantic is mostly identical to that of Julia. Thus, it is probably best to
implement the syntax atop Julia or Julia's IR.
</p>

<p>
It might also make sense to freely mix Julia and Bisp at the top-level and by a
<code>(JL 1+2*3)</code> syntax for e.g. mathematical equations:
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; julia code
struct Pad end
foo(a,b) = a + b
;; Bisp code
(defn bar [a] (foo a 1))
(def var (JL
          1 .+ ones(3,2) .* zeros(2,3)))
</pre>
</div>

<p>
Julia and Bisp functions can be freely called by each other as well.
</p>

<p>
In summary, implementing Bisp on top of Julia gives:
</p>
<ul class="org-ul">
<li>easy to implement</li>
<li>Julia's JIT compiler, optimization, LLVM backend provides a solid performance
fundation.</li>
<li>access to all those Julia libraries, thus this might be the first lisp-for-statistics</li>
</ul>
</div>

<div id="outline-container-org1c2ee91" class="outline-4">
<h4 id="org1c2ee91"><span class="section-number-4">1.3.1</span> UPDATE 1</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
I found syntactic abstraction harder to reimplement than multiple dispatch, thus
it seems quite easy to implement the rough BISP on top of racket, and I should
be able to use all racket's amazing libraries. However, naive multiple
dispatching might produce inefficient code, thus I probably need to look into
optimization at some point.
</p>

<p>
And I still want to use Julia's library and all other language's libraries. But
instead of native foreign function interface, I prefer something that I coined
(HEBI: "source-level FFI"). This is a HUGE idea. For Julia, I will need to
implement a syntactic expander for Julia's macros, and a Julia syntac
transformer to load Julia's code directly into racket. Julia code might make
base library calls or C FFIs. In this case, I would need to map Julia base
library call to racket, and make corresponding C native FFI. I'm not sure how
possible it is to map the entire Julia base library.
</p>

<p>
Actually, I don't need to really implement the subtyping and union type.  That
is needed, but not urgently useful, I can live without it for now.  This will
make the dispatching much simpler, because the ordering of methods based on
specificity is easier, I just need to order all custom types before non-typed
ones. And I need to properly mix the primitive types and user-defined
types. Most likely I need to have a wrapper name (via syntax) for each of the
primitive types. See <a href="https://docs.racket-lang.org/ts-reference/type-ref.html">https://docs.racket-lang.org/ts-reference/type-ref.html</a> for
a list.
</p>

<p>
Importantly, the struct field access should be converted to generic methods.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgbe1320a" class="outline-2">
<h2 id="orgbe1320a"><span class="section-number-2">2</span> The Language</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgf2b434b" class="outline-3">
<h3 id="orgf2b434b"><span class="section-number-3">2.1</span> Field Accessing with Dot-Notation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Prior art: cubersome struct field accessing, the dot-notation is missing
</p>

<div class="org-src-container">
<pre class="src src-racket">;; struct
(struct Rect w h)
(let ([r (Rect 2 3)])
  ;; field accessing is cubersome
  (* (Rect-w r)
     (Rect-h r)))
</pre>
</div>

<p>
The problems:
</p>
<ul class="org-ul">
<li><code>(foo-a x)</code>, not elegent</li>
<li>The pattern matching with destructuring binds
<ul class="org-ul">
<li>fragile</li>
<li>have to bind all the fields</li>
</ul></li>
</ul>

<p>
Instead, Bisp uses dot-notation:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(defstruct Rect
  w::Number h)

(defstruct Circle r)

(let [a (Rect)
      b (Circle)]
  ;; access using dot notation
  (+ a.w b.r))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0aaaf31" class="outline-3">
<h3 id="org0aaaf31"><span class="section-number-3">2.2</span> Multi-Dimensional Array: Indexing and Slicing</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Prior art: hard to do array indexing and slicing, e.g. the racket way:
</p>

<div class="org-src-container">
<pre class="src src-racket">;; array indexing and slicing
(array-ref arr #(2 3))
(array-set! brr #(2 3) 10)
(array-slice-ref arr (list (::) (:: #f #f -1)))
</pre>
</div>


<p>
Bisp uses postfix indexing and slicing:
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; define an array
(def arr (ones 3 2))
;; indexing: I found comma probably makes it more clear here
arr[1, 2]
;; slicing
arr[:, 0:1]

;; array type
(defn foo [a::Array{Any 3} b]
  nil)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8dca38f" class="outline-3">
<h3 id="org8dca38f"><span class="section-number-3">2.3</span> Optional Inline Type Annotation</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Previous lisp is hard to do inline type annotations.  Prior art: typed racket,
contracts, clojure specs.
</p>

<p>
For example, typed racket:
</p>

<div class="org-src-container">
<pre class="src src-racket">;; outline annotation
(: distance (-&gt; pt pt Real))
(define (distance p1 p2)
  (sqrt (+ (sqr (- (pt-x p2) (pt-x p1)))
           (sqr (- (pt-y p2) (pt-y p1))))))

;; inline annotations
(let ([x : Number 7])
  (add1 x))
(lambda ([x : Number] [y : String]) (+ x 5))
</pre>
</div>

<p>
The problems:
</p>
<ul class="org-ul">
<li>I prefer inline type annotation</li>
<li>the inline notation of the typed racket introduces extra parenthesis, due to
added spaced words.</li>
</ul>

<p>
Instead, the type annotations in Bisp simply uses <code>y::String</code> <b>without extra
spaces</b>, and it should be nice and clear:
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; optional type
(defn foo [a::Number b] nil)
(defn foo [a::String b] nil)
;; union type
(defn foo [a::Union{Integer, Float} b] nil)
</pre>
</div>

<p>
Support parametric types
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; parametric type
(defn foo [a::Number b c::T d::T
           #:where (&lt;: T Real)]
  nil)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4654be" class="outline-3">
<h3 id="orgb4654be"><span class="section-number-3">2.4</span> Multi-Dispatch Generic Functions by Default</h3>
<div class="outline-text-3" id="text-2-4">
<p>
ALL functions are generic methods. You define the same name multiple times
(instead of define <code>foobar-number</code>, <code>foobar-string</code>), and they are dispatched
upon calling:
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; by default, all functions are methods
(defn foo [a] nil)
(defn foo [a b] "no annotation")
;; optional type
(defn foo [a::Number b] "number")
(defn foo [a::String b] "string")

foo
; =&gt; generic function with 4 methods
</pre>
</div>
</div>
</div>

<div id="outline-container-org8913a01" class="outline-3">
<h3 id="org8913a01"><span class="section-number-3">2.5</span> function defs, default and keyword arguments</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Bisp is lisp-1, i.e. unified namespace for functions and variables. Functions
are first-class, the following defs are equivalent:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(defn foo [a b] nil)
;; same as
(def foo (Î» [a b] nil))
</pre>
</div>

<p>
Default arguments are given by infix notation. You don't specify type and
default value together because it can be inferred by the value. All default
values must be after non-default ones.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(defn foo [a b=3 c="default"] nil)
</pre>
</div>

<p>
Keyword arguments are whatever after <code>&amp;</code>:
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; keyword arguments separated by #:key. Here default values can be in any order
(defn foo [a::Number b c=3
           &amp; x::String y z="defz"]
  nil)
;; function call with keyword arguments
(foo 1 2 x="X" y=8)
</pre>
</div>

<p>
varargs support with intuitive <code>...</code> syntax as Julia, in both function defs and
callsite, and wherever makes sense:
</p>

<div class="org-src-container">
<pre class="src src-clojure">;; var args in both function definition and callsite
(defn foo [a::String b::Number args...]
  body)
(foo "hello" 8 '(a l i s t)...)

;; also support slicing inside a list or wherever appropriate, not just function callsite
(1 2 '(3 4 5)... 6 7)
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
