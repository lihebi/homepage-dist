<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Machine Learning</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/assets/org.css" /><link rel="stylesheet" type="text/css" href="/assets/hebi.css" /><link rel="stylesheet" type="text/css" href="assets/org.css" /><link rel="stylesheet" type="text/css" href="assets/hebi.css" /><link rel="stylesheet" type="text/css" href="../assets/org.css" /><link rel="stylesheet" type="text/css" href="../assets/hebi.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">Machine Learning</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7762e8d">1. Tmp</a></li>
<li><a href="#org8f0fce5">2. Supervised Learning</a>
<ul>
<li><a href="#orgaccd240">2.1. General Concepts</a></li>
<li><a href="#org7a43b96">2.2. Linear Regression</a></li>
<li><a href="#org4e4e2b2">2.3. Linear Classification</a></li>
<li><a href="#orga82edd9">2.4. Basis Expansion and Regularization</a></li>
<li><a href="#org25ea4c0">2.5. KNN</a></li>
<li><a href="#org6aa0bc1">2.6. Subset selection</a></li>
<li><a href="#orgb5671c7">2.7. Kernel Methods and local regression</a></li>
<li><a href="#orgd5684f2">2.8. High Dimension</a></li>
<li><a href="#orga6df667">2.9. Model Assessment</a></li>
<li><a href="#org51a234d">2.10. Model Inference</a></li>
<li><a href="#org2fbd56c">2.11. Maximum Likelihood Inference</a></li>
<li><a href="#orgf0acae2">2.12. Tree-based method</a></li>
<li><a href="#orgcf6c2bd">2.13. Additive Model</a></li>
<li><a href="#org27dfca7">2.14. Other</a></li>
</ul>
</li>
<li><a href="#org7613820">3. Support Vector Machine</a></li>
<li><a href="#org4e3a0ba">4. Unsupervised Learning</a>
<ul>
<li><a href="#org5a894f0">4.1. K-means</a></li>
<li><a href="#orgcc11fcd">4.2. Hierarchical Clustering</a></li>
</ul>
</li>
</ul>
</div>
</div>
<blockquote>
<p>
All models are wrong, but some are useful.
</p>
</blockquote>

<div id="outline-container-org7762e8d" class="outline-2">
<h2 id="org7762e8d"><span class="section-number-2">1</span> Tmp</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>false positive: error, output true, but supposed to output false</li>
<li>false negative: error, output false</li>
<li>true positive: correct</li>
<li>true negative: correct</li>
</ul>
</div>
</div>

<div id="outline-container-org8f0fce5" class="outline-2">
<h2 id="org8f0fce5"><span class="section-number-2">2</span> Supervised Learning</h2>
<div class="outline-text-2" id="text-2">
<p>
The <i>input</i> is also called <i>predictors</i>, <i>independent variables</i>, or
<i>features</i>. The <i>output</i> is also called <i>response</i> or <i>dependent
variables</i>.
</p>

<p>
The <i>quantitative measurement</i> means some measurements are bigger than
others, and they are close in value means they are close in nature as
well. <i>Qualitative variables</i> are also refereed to as <i>categorical
variable</i> or <i>discrete variable</i>.  We call a problem <i>regression</i> when
we predict quantitative outputs, and <i>classification</i> when we predict
qualitative outputs.
</p>

<p>
Parameter based approaches, like linear models, make huge assumptions
about the structure, thus are stable (the decision boundary is very
smooth) but inaccurate. Non-parametric methods, like k-nearest
neighbors, makes very mild structural assumptions, thus often accurate
but not stable. Since it makes very mild assumption, it can adapt to
many situations.
</p>
</div>

<div id="outline-container-orgaccd240" class="outline-3">
<h3 id="orgaccd240"><span class="section-number-3">2.1</span> General Concepts</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Euclidean distance</li>
<li id="parametric method">reduce the fitting problem to estimating a set
of coefficients.  But it will be imprecise if the model choose-d
is very different from the true model</li>
<li id="non-parametric method">a very large number of observations is
required.</li>
</ul>
</div>
</div>


<div id="outline-container-org7a43b96" class="outline-3">
<h3 id="org7a43b96"><span class="section-number-3">2.2</span> Linear Regression</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<i>Least square</i> method is the one that train the model by minimizing
the <i>residual sum of square (RSS)</i>, defined as where \(\beta\) is the
coefficients:
</p>

<p>
\[RSS(\beta) = \sum_{i=1}^{N} (y_i - x_i^T \beta)^2\]
</p>

<p>
It can also be represented as vector product:
</p>

<p>
\[RSS(\beta) = (y - X\beta)^T (y - X\beta)\]
</p>

<p>
Differentiating with respect to \(\beta\):
</p>

<p>
\[\frac{\partial RSS}{\partial{\beta}} = -2X^T (y-X\beta)\]
\[\frac{\partial^2 RSS}{\partial \beta \partial \beta^T} = 2X^TX\]
</p>

<p>
Setting the first derivative to zero, we obtain the result
\[X^T(y-X\beta) = 0\]
\[\hat{\beta} = (X^TX)^{-1}X^Ty\]
</p>

<p>
Further we can have the prediction of y being
</p>

<p>
\[\hat{y} = X\hat{\beta} = X(X^TX)^{-1}X^Ty = Hy\]
</p>

<p>
Where \(H=X(X^TX)^{-1}X^T\) is called <i>hat matrix</i> because it puts hat
on \(y\). On the geometrical representation, we can see actually \(H\)
computes the orthogonal projection of y onto the space created by the
input vector \(x\). Thus it is also called <i>projection matrix</i>.
</p>

<p>
To test the hypothesis that a particular coefficient \(\beta_j=0\), we
need <i>Z-score</i>. To test for a group of coefficients simultaneously, we
use <i>F-statistic</i>.
</p>

<p>
The <i>Gauss-Markov theorem</i> states that the least squares estimates of
the parameters \(\beta\) have the smallest variance among all linear
unbiased estimates. Formally, if we have any other linear estimator
\(\theta=c^Ty\) that is unbiased for \(a^T\beta\),
i.e. \(E(c&Ty)=a^T\beta\), then
</p>

<p>
\[Var(a^T\hat{\beta}) \le Var(c^Ty)\]
</p>

<p>
This theorem implies that the least square estimator has the smallest
mean square error of all linear estimators with no bias.
</p>

<p>
In terms of multiple variables, the model is called <i>multiple linear
regression model</i>. The one variable version is thus called <i>univariate
linear model</i>. <i>Gram-Schmidt procedure</i> is used for <i>multiple
regression</i>. In case of multiple outputs, they do not affect one
another's least square estimate.
</p>
</div>
</div>

<div id="outline-container-org4e4e2b2" class="outline-3">
<h3 id="org4e4e2b2"><span class="section-number-3">2.3</span> Linear Classification</h3>
<div class="outline-text-3" id="text-2-3">
<p>
This kind of problem estimate \(Pr(G=k|X=x)\) where G is the categories.
</p>

<p>
<i>Bayes classifier</i>: classify to the most probable class, using
conditional distribution. The error rate of Bayes classifier is called
<i>the Bayes rate</i>.
</p>

<dl class="org-dl">
<dt>Bayes Classifier</dt><dd>assign each observation to the most likely
class, given its predictor values.</dd>
<dt>Bayes Error Rate</dt><dd>Bayes classifier produces the lowest possible
test error rate.  The Bayes error rate is analogous to the
irreducible error.  This means it is the optimal value.  So Bayes
classifier serves as an unattainable gold standard against which
to compare other methods.</dd>
<dt>Bayes Decision Boundary</dt><dd>determine the prediction</dd>
</dl>

<p>
<i>Linear Discriminant Analysis (LDA)</i> solves the case when we assume
the classes have a common covariance matrix. If this assumption is not
correct, we use <i>Quandratic Discriminant Analysis (QDA)</i>. There is a
method <i>Regularized Discriminant Analysis (RDA)</i> that compromises
between LDA and QDA, and allows one to shrink the separate covariances
of QDA toward a common covariance as in LDA, very similar to ridge
regression.
</p>

<p>
How to choose from LDA or QDA depends on the bias-variance trade-off.
LDA is better when:
</p>
<ul class="org-ul">
<li>LDA is a much less flexible classifier than QDA.</li>
<li>So it has a much lower variance.</li>
<li>It improve the prediction performance.</li>
</ul>
<p>
QDA is better when:
</p>
<ul class="org-ul">
<li>if the assumption of common covariance matrix is bad, LDA is bias</li>
<li>if the training set is very large, the variance of the classifier is
not a major concern.</li>
</ul>

<p>
The posterior probabilities of K classes are not sum to 1. But this is
often not convenient. So <i>logistic regression</i> is invented. It models
the posterior probabilities of K classes via linear functions in \(x\),
while at the same time ensuring that they <b>sum to one and remain in
[0,1]</b>. The model has the form of K-1 <i>log-odds</i>, or <i>logic
transformation</i>:
</p>

\begin{eqnarray}
log \frac{Pr(G=1|X=x)}{Pr(G=K|X=x)} & = & \beta_{10} + \beta_1^Tx\\
log \frac{Pr(G=2|X=x)}{Pr(G=K|X=x)} & = & \beta_{20} + \beta_2^Tx\\
\cdots\\
log \frac{Pr(G=K-1|X=x)}{Pr(G=K|X=x)} & = & \beta_{(K-1)0} + \beta_(K-1)^Tx\\
\end{eqnarray}

<p>
The logistic regression model are usually fit by maximum likelihood,
using the conditional likelihood of G given X. The log-likelihood for
N observations is:
</p>

<p>
\[\ell(\theta) = \sum_{i=1}^N log p_{g_i} (x_i;\theta)\]
</p>

<p>
Where \(p_k(x_i;\theta) = Pr(G=k|X=x_i;\theta)\), and this can be
obtained from the model definition. Take the derivation and set to
zero, and take the second-order derivation (i.e. Hessian matrix), we
can get the solution to the optimization problem.
</p>

<p>
Logistic regression models are used mostly as a data analysis and
inference tool, where the goal is to understand the role of the input
variables in <i>explaining</i> the outcome.
</p>

<p>
The LDA and logistic regression appear very similar. The difference
lies in the way the linear coefficients are estimated. The logistic
regression is more general in that it makes less assumptions. The
logistic regression estimate the parameter by maximizing the
conditional likelihood \(Pr(G=k|X)\), while the LDA maximize the full
log-likelihood \(Pr(X,G=k)\).
</p>
</div>
</div>

<div id="outline-container-orga82edd9" class="outline-3">
<h3 id="orga82edd9"><span class="section-number-3">2.4</span> Basis Expansion and Regularization</h3>
<div class="outline-text-3" id="text-2-4">
<p>
These linear model can be extended to non-linear through simple
transformations.
</p>

<p>
<i>Basis expansion</i> applies a function transformation on the input, to
transform it and use the result as the new input. For example, we can
use \(x_i^2\) as the input, and thus linear regression can have
non-linear (in this case polynomial) results. Specifically the model
has the form:
</p>

<p>
\[f(X) = \sum_{m=1}^M \beta_m h_m(X)\]
</p>

<p>
Where \(h_m\) is the transformation function. 
</p>

<p>
Polynomial regression is just replace standard linear model to higher
dimension ones (typically less than 4).  The one with \(X,X^2,X^3\) is
called cubic regression.
</p>

<p>
The first kind of transformation is to divide the input X into
continuous intervals, and represent each interval a polynomial
function. This is called <i>piecewise polynomial</i> or <i>spline</i>.
</p>

<p>
Also called <i>piecewise constant regression</i>.  It actually piecewise
the data, and do linear regression.  The linear model is
</p>

\begin{eqnarray}
y_i = \beta_0 + \beta_1 C_1(x_i) + \beta_2 C_2(x_i) + ... + \beta_K C_K(x_i) + \epsilon_i
\end{eqnarray}

<p>
Given a value X, there's at most one of \(C_i\) can be non-zero.
</p>

<p>
<i>regression spline</i> is piecewise polynomial.  But it ensures the
smooth at the knots.  We have K knots, and fit a cubic regression.  At
the knots, we need to ensure the 0,1,2 deviation is the same.
</p>

<p>
Adaptively chosen basis function methods are known as <i>dictionary
methods</i>.
</p>

<p>
<i>Regularization method</i> is also called <i>penalty function</i>. It
expresses our prior belief that the type of functions we seek exhibit
a certain type of smooth behavior. This is realized through
introducing a penalizing function to RSS:
</p>

<p>
\[PRSS(f;\lambda) = RSS(f) + \lambda J(f)\]
</p>

<p>
The \(\lambda\) is called <i>smoothing parameter</i>, and is fixed.  \(J(f)\)
should be chosen such that it will be large for functions f that vary
too rapidly over small regions of input space. For example, for <i>cubic
smoothing spline</i>, it is
</p>

<p>
\[PRSS(f;\lambda) = \sum_{i=1}^N (y_i - f(x_i))^2 + \lambda \int
[f''(x)]^2dx\]
</p>

<p>
The smoothing parameter encodes the degree of the spline, and the
number and placement of <i>knots</i>, and can be automatically selected.
</p>

<p>
<i>Smoothing spline</i> is a different approach, but also produces a
spline.  Instead of making RSS minimal, we make the following minimal
</p>

\begin{eqnarray}
RSS = \sum_{i=1}^n (y_i - g(x_i))^2
\end{eqnarray}

<p>
We need to find a \(g\).  If we do not put any constraints, we can
simply let \(g\) equal to \(y_i\).  But this is overfitting.  We need some
constraints on \(g\).  We want to find the \(g\) that minimizes:
</p>

\begin{eqnarray}
\sum_{i=1}^n (y_i - g(x_i))^2 + \lambda \int g''(t)^2dt
\end{eqnarray}

<p>
The function \(g\) that minimizes it is a smoothing spline.
</p>

<p>
The first term is a <i>loss function</i>, nd second is a <i>penalty term</i>.
</p>
</div>
</div>

<div id="outline-container-org25ea4c0" class="outline-3">
<h3 id="org25ea4c0"><span class="section-number-3">2.5</span> KNN</h3>
<div class="outline-text-3" id="text-2-5">
<p>
In KNN, all data are the model. The prediction is made by averaging
the nearest k observations. In particular, the output is computed by:
</p>

<p>
\[\hat{Y}(x) = \frac{1}{k} \sum_{x_i \in N_k(x)} y_i\]
</p>

<p>
Where the \(N_k(x)\) is the k closest points of \(x\) in the training
sample.
</p>
</div>
</div>

<div id="outline-container-org6aa0bc1" class="outline-3">
<h3 id="org6aa0bc1"><span class="section-number-3">2.6</span> Subset selection</h3>
<div class="outline-text-3" id="text-2-6">
<p>
For two reasons we might want to use subset of input:
</p>
<ol class="org-ol">
<li>prediction accuracy: the least square estimates often have low bias
but large variance.</li>
<li>interpretation: we would like to determine a smaller subset that
exhibit the strongest effects.</li>
</ol>

<p>
The <i>best-subset selection</i> explore all possible subset and select the
one with the smallest residual sum of square (RSS). However, this is
of course expensive. Instead, we can use a search. The <i>forward
step-wise selection</i> starts with the intercept, then sequentially adds
into the model the predictor that improves the fit the most. Clearly
this is a greedy algorithm. The <i>backward step-wise selection</i> starts
with the full model, and sequentially deletes the predictor that has
the least impact to the fit. The candidate for dropping is the one
with the smallest Z-score. There is also another called <i>forward
stage-wise regression (FS)</i>, which is more constrained. At each step,
it identifies the variable most correlated with the current residual,
then computes the simple linear regression coefficient on this chosen
variable, then adds it to the corrent coefficient for that
variable. This process continue until none of the variable have
correlation with the residual, i..e the least square fit. Unlike the
forward step-wise regression, none of hte other variables are adjusted
when a term is added to the model. As a result, it may take more
steps. However, this "slow fitting" seems to be more effective in
high-dimensional problems. There is also a hybrid approach.  After
adding each new variable, the method may also remove any variables
that no longer provide an improvement.
</p>

<p>
<i>Shrinkage method</i> is a generalize of the subset selection. Subset
selection remove a variable at one time, in another word, it is
discrete process. Thus it exhibits high variance.
</p>

<p>
<i>Ridge regression</i> shrinks the regression coefficients by imposing a
penalty on their size. Ridge regression protects against the
potentially high variance of gradients estimated in the short
direction. The assumption is that the response will tend to vary most
in the directions of high variance of the input. Thus the name
"ridge".
</p>

<p>
The ordinary least squares minimize:
</p>
\begin{eqnarray}
RSS = \sum_{i=1}^n (y_i - \beta_0 - \sum_{j=1}^p \beta_j x_{ij})^2
\end{eqnarray}

<p>
and ridge regression introduce a <i>shrinkage penalty</i>:
</p>

\begin{eqnarray}
RSS + \lambda \sum_{j=1}^p \beta^2_j
\end{eqnarray}

<p>
When \(\beta_j\) is small toward 0, the above added penalty will be small.
So it will make the \(\beta_j\) smaller, i.e. shrinkage.
The parameter \(\lambda\) is critical for the influence of the penalty.
</p>

<p>
Actually it uses the l<sub>2</sub> norm.
</p>
\begin{eqnarray}
||\beta||_2 = \sqrt{\sum_{j=1}^p} \beta^2_j
\end{eqnarray}


<p>
<i>Principal Components Regression (PCR)</i> and <i>Partial Least Square
(PLS)</i> use derived input. PCR uses all the input, but PLS also uses
\(y\) in addition to \(x\). Both are similar to Ridge regression because
they shrinks smoothly.
</p>

<p>
<i>Lasso</i> falls somewhere between ridge regression and best subset
regression.
</p>

<p>
Ridge regression cannot remove any features, unless \(\lambda =
\infty\).  This may not be a problem for prediction accuracy but it can
create a challenge in model interpretation.
</p>

<p>
The Lasso uses l<sub>1</sub> norm penalty.
</p>

\begin{eqnarray}
||\beta||_1 = \sum |\beta_j|
\end{eqnarray}

<p>
\(l_1\) penalty has the effect of forcing some of the coefficient
estimates to be <i>exactly</i> equal to 0 when the tuning parameter
\(\lambda\) is sufficiently large.
</p>

<p>
It is much easier to interpret, it yields <i>sparse</i> model, i.e. models
that involve only a subset of the variables.
</p>

<p>
As a conclusion, ridge regression does a proportional shrinkage. Lasso
translate each coefficient by a constant factor, truncating at
zero. Best-subset selection drops all variables with coefficients
smaller than the M-th largest.
</p>
</div>
</div>

<div id="outline-container-orgb5671c7" class="outline-3">
<h3 id="orgb5671c7"><span class="section-number-3">2.7</span> Kernel Methods and local regression</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Kernel means local. Kernel method is generally applicable, e.g. to
KNN. KNN is discontinuous, but this is not necessary. The idea is to
use only observations close to target point to make fit the model.
This is achieved by assigning a kernel function \(K_\lambfda(x_0,x)\)
which assigns weights to the points in the region near \(x_0\)
(according to distance). The model, however, is the entire training
data. As a result, the RSS to minimize becomes:
</p>

<p>
\[RSS(f_\theta, x_0) = \sum_{i=1}^N K_\lambda (x_0, x_i)(y_i -
f_\theta (x_i))^2\]
</p>

<p>
The \(\lambda\) is a parameter that control the width of the
kernel. However, local regression becomes less useful in dimensions
much higher than 2. It is impossible to simultaneously maintain
localness (low bias) and a sizable sample in the neighborhood (low
variance) as the dimension increases, without the total number of
sample increasing exponentially. This can not be solved unless we make
some structural assumption about the model.
</p>
</div>
</div>

<div id="outline-container-orgd5684f2" class="outline-3">
<h3 id="orgd5684f2"><span class="section-number-3">2.8</span> High Dimension</h3>
<div class="outline-text-3" id="text-2-8">
<p>
It seems that for KNN, if given more data, we can make more precise
predictions. However, this intuition does not work when the dimension
is high. This is known as <i>curse of dimensionality</i>.  This is because
if the dimension is high, the KNN need not to be close to the target
point. In general, any method that attempts to produce local varying
functions in small isotropic neighborhoods will run into problems in
high dimensions.
</p>

<p>
Dimension Reduction techniques are discussed here.
</p>

<p>
linear combination of the predictors into M new predictors.
</p>

\begin{eqnarray}
Z_m = \sum_{j=1}^p \phi_{jm} X_j
\end{eqnarray}


<p>
<i>Principal Component Analysis (PCA)</i>: The following are some criteria
for the direction selection, they all talk about the same thing:
</p>
<ul class="org-ul">
<li>The first principal component direction is that along which the
observation vary the most.</li>
<li>This also yields the highest variance.</li>
<li>It also defines the line that is as close as possible to the data.</li>
<li>projected observations are as close as possible to the original
observations.</li>
</ul>

<p>
The second principal component \(Z_2\) is a linear combination of the
variables that is uncorrelated with \(Z_1\), and has largest variance
subject to this constraint.  Actually \(Z_1\) and \(Z_2\) are always
orthogonal.
</p>

<p>
<i>Principal Component Regression (PCR)</i>: Construct the first M
principal components, and do linear regression on the new predictors.
</p>

<p>
<i>Partial Least Squares (PLS)</i>: The directions identified by PCA is in
an unsupervised way, i.e. it does not use response Y.
</p>

<p>
Set each \(\phi_{j1}\) equal to the coefficient from teh simple linear
regression of Y onto X<sub>j</sub>.  Intuitively PLS places the highest weight
on the variables that are most strongly related to the response.
</p>

<p>
Second PLS direction is by
</p>
<ol class="org-ol">
<li>adjust each of the variables for Z<sub>1</sub>, by regressing each variable
on Z<sub>1</sub> and taking residuals This captures the remaining information
that has not been explained by the first PLS direction</li>
<li>use this orthogonalized data in exactly the same fashion as Z<sub>1</sub>.</li>
<li>Repeat M times.</li>
</ol>
</div>
</div>


<div id="outline-container-orga6df667" class="outline-3">
<h3 id="orga6df667"><span class="section-number-3">2.9</span> Model Assessment</h3>
<div class="outline-text-3" id="text-2-9">
<p>
<i>Test error</i> is also called <i>generalization error</i>, <i>prediction
error</i>, and is the error over test sample. <i>Training error</i> is the
error on training sample.
</p>

<p>
<i>mean square error (MSE)</i> is defined as:
</p>

\begin{eqnarray}
MSE = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{f}(x_i))^2
\end{eqnarray}

<p>
The bias-variance trade-off:
</p>
<dl class="org-dl">
<dt>variance</dt><dd>the amount by which \(\hat{f}\) would change if we
estimated it using a different training data set.  <i>More
flexible statistical methods have higher variance.</i></dd>
<dt>bias</dt><dd>the error that is introduced by approximating a real-life
problem.  E.g. it is unlikely that any real-life problem has
simple linear relationship.  <i>More flexible methods result
in less bias.</i></dd>

<dt>95% confidence interval</dt><dd>a range of values such that with 95%
probability, the range will contain the true unknown value of the
parameter.</dd>
</dl>

<p>
The prediction error can be assessed by some criterion. <i>Akaike
Information Criterion (AIC)</i> is defined as
</p>

<p>
\[AIC = - \frac{2}{N} loglik + 2 \frac{d}{N}\]
</p>

<p>
<i>Bayesian Information Criterion (BIC)</i>, also known as <i>Schwarz
criterion</i>, is similar to AIC, and defined as:
</p>

<p>
\[BIC = -2 loglik + (log N) d\]
</p>

<p>
Choosing the model with minimum BIC is equivalent to choosing the
model with largest (approximate) posterior probability, thus the name.
The <i>Minimum Description Length (MDL)</i> is formally identical to BIC,
but from different point of view.
</p>

<p>
AS the <i>model complexity</i> increases, the variance tends to increase
and the squared bias tends to decrease. <i>Vapnik-Chervonenkis Dimension
(VC-Dimension)</i> provides the measurement of model complexity.
</p>

<p>
In <i>K-fold cross validation</i>, we split the data into K roughly
equal-sized parts. For the k-th part, we fit the model using other
data, and use it as the test data. The prediction error is the average
of the K experiments. When K=N, it is called <i>leave-one-out
cross-validation</i>. In this case, it is unbiased, but has high
variance.
</p>

<p>
The <i>bootstrap method</i> is also for assessing the accuracy, as cross
validation. It randomly draw-with-replacement from the training
data. This is done B times, and producing B bootstrap datasets. The
model is fit on each of the data set, and all the prediction errors
are examined. 
</p>
</div>
</div>

<div id="outline-container-org51a234d" class="outline-3">
<h3 id="org51a234d"><span class="section-number-3">2.10</span> Model Inference</h3>
<div class="outline-text-3" id="text-2-10">
<dl class="org-dl">
<dt>prediction</dt><dd>\(\hat{f}\) is treated as black box</dd>
<dt>inference</dt><dd>understand the relationship between X and Y.  \(\hat{f}\)
cannot be treated as black box.</dd>
</dl>

<p>
Model inference is the problem of estimate the model parameters.
</p>

<p>
The above bootstrap can be used for model inference. This is called
<i>non-parametric bootstrap</i>. The <i>parametric bootstrap</i> does not use
raw data, but simulate the new response by adding Gaussian noise to
the predicted values.
</p>

<p>
In essence, bootstrap is a computer implementation of nonparametric or
parametric maximum likelihood. Also, bootstrap distribution represents
an (approximate) nonparametric, noninformative posterior distribution
for the parameter. But this bootstrap distribution is obtained
painlessly, without having to specify a prior, and without having to
sample from the posterior distribution. Thus, the bootstrap
distribution is also called "poor man's" Bayes posterior.
</p>

<p>
In Bayesian model, we need to draw samples from the resulting
posterior distribution. Typically the <i>Markov Chain Monte Carlo
(MCMC)</i> method is used. Gibbs is one kind of MCMC.
</p>

<p>
<i>Bagging</i> is also called <i>bootstrap aggregation</i>, it is a method to
use bootstrap not to access the accuracy, but to improve the
prediction itself. It makes the prediction over a collection of
bootstrap samples, thus reducing the variance. The prediction result
is defined as the averaging of all predictors for all samples.
</p>

<p>
The decision tree suffers from high variance.  If we split the
training data into two parts at random, the result two trees can be
very different.  Bagging can reduce the variance.  It is related to
bootstrap.
</p>

<p>
Bagging involves
</p>
<ol class="org-ol">
<li>creating multiple copies of the original training data set using
the bootstrap,</li>
<li>fitting a separate decision tree to each copy,</li>
<li>and then combining all of the trees in order to create a single
predictive model.</li>
</ol>

<p>
Each tree is built on a bootstrap data set, independent of the other
trees.  The key idea is averaging a set of observations reduces
variance.
</p>

<p>
<i>Random Forrest</i> is a substantial modification of bagging that builds
a collection of trees and then averages them. The essential idea in
bagging is to average many noisy but approximately unbiased models,
and hence reduce the variance. Trees are ideal candidates for bagging
because they can capture complex interaction structure in the data,
and if grown sufficiently deep, have relatively low bias. However, the
size of the correlation of bagged trees limits the benefit of
averaging. The random forest is to improve the variance reduction of
bagging by reducing the correlation between trees, without increasing
the variance too much. This is achieved in the tree-growing process
through random selection of the input variables. Specifically:
</p>

<blockquote>
<p>
Before each split, select \(m\le p\) of the input variables at random as
candidates for splitting.
</p>
</blockquote>

<p>
<i>Bumping</i> is also based on bootstrap, but is a stochastic process: it
randomly walk through all the models in the bootstrap samples. This
helps the fitting to avoid getting stuck in (some?) local minima.
</p>
</div>
</div>

<div id="outline-container-org2fbd56c" class="outline-3">
<h3 id="org2fbd56c"><span class="section-number-3">2.11</span> Maximum Likelihood Inference</h3>
<div class="outline-text-3" id="text-2-11">
<p>
Given a probability density or probability mass function for the
observation:
</p>

<p>
\[z_i \sim g_\theta(z)\]
</p>

<p>
where the \(\theta\) is unknown parameter. The maximum likelihood
function is:
</p>

<p>
\[L(\theta;Z) = \prod_{i=1}^N g_\theta(z_i)\]
</p>

<p>
This is <b>the probability of the observed data under the model
\(g_\theta\)</b>. The log of this likelihood, is called the log-likelihood:
</p>

<p>
\[\ell(\theta;Z) = \sum_{i=1}^N \ell(\theta;z_i) = \sum_{i=1}^N log
g_\theta(z_i)\]
</p>

<p>
Each value in the summary is called log-likelihood component. The
method of maximum likelihood chooses the value of \(\theta\) to maximize
\(\ell(\theta;Z)\).
</p>
</div>
</div>

<div id="outline-container-orgf0acae2" class="outline-3">
<h3 id="orgf0acae2"><span class="section-number-3">2.12</span> Tree-based method</h3>
<div class="outline-text-3" id="text-2-12">
<p>
<i>Tree-based methods</i> partition the feature space into a set of
rectangles, then fit a model in each one.
</p>

<p>
<i>regression tree</i>:
</p>
<ol class="org-ol">
<li>divide the predictor space into J distinct and non-overlapping
regions \(R_1,...,R_J\).</li>
<li>for each observation fail into R<sub>j</sub>, make the prediction using the
mean in R<sub>j</sub>.</li>
</ol>

<p>
To get the regions, use <i>recursive binary splitting</i>, a top-down,
greedy approach.
</p>
<ul class="org-ul">
<li>From the root</li>
<li>every split choose the best split that leads to the greatest
possible reduction of RSS</li>
</ul>

<p>
It is likely to overfit the data.  So we can grow a very large tree,
and then <i>prune</i> it back in order to obtain a subtree.
</p>

<p>
The whole algorithm goes here:
</p>
<ol class="org-ol">
<li>recursive binary splitting to grow a large tree</li>
<li>apply <i>cost complexity pruning</i></li>
<li>use <i>K-fold cross-validation</i></li>
</ol>

<p>
<i>Patient Rule Induction Method (PRIM)</i> is also a tree-based method,
but with different splitting approach. It seeks for boxes in which
response average is high. Hence, it looks for maxima in the target
function. It works from the top down, starting with a box containing
all the data. It repeatedly peel off data.
</p>

<p>
<i>Hierarchical Mixture of Experts (HME)</i> is a variant of tree-based
method. The tree split not by hard decision, but by probability. The
observation goes left or right with probability depending on its input
value. The terminal node is called <i>expert</i>, the non-terminal node is
called <i>gating networks</i>. The idea is that each expert provides an
opinion (prediction) about the response, and these are combined
together by the gating network.
</p>
</div>
</div>

<div id="outline-container-orgcf6c2bd" class="outline-3">
<h3 id="orgcf6c2bd"><span class="section-number-3">2.13</span> Additive Model</h3>
<div class="outline-text-3" id="text-2-13">
<p>
<i>Generalized Additive Model (GAM)</i> has the form
</p>

<p>
\[E(Y|X_1,X_2,...,X_p) = \alpha + f_1(X_1) + f_2(X_2) + ... + f_p(X_p)\]
</p>

<p>
where the \(f_i\) are unspecified smooth (nonparametric) functions. It
is called additive model because we calculate a separate \(f_j\) for
each \(X_j\), and add together all of their contributions.  Additive
models provide a useful extension of linear models, making them more
flexible while retaining much of their interpretability.
</p>

<p>
<i>Boosting method</i> combines the output of many weak classifier to
produce a powerful committee, through a weighted majority vote, with
the assumption that they do not make the same mistake.
</p>

<p>
<i>Boosting</i> is another approach for improving the prediction results from
 a decision tree.  The different from bagging is,
</p>
<ul class="org-ul">
<li>the trees are grown sequentially: each tree is grown using
information from previously grown trees.</li>
<li>Boosting does not involve bootstrap sampling.  Each tree is fit on a
modified version of the original data set.</li>
</ul>

<p>
<i>Ensemble learning</i> builds a prediciton model by combining the
strengths of a collection of simpler base models. Bagging and random
forest are ensemble methods for classification. The <i>Importance
Sampled Learning Ensemble (ISLE)</i> is one ensemble-generation method.
</p>
</div>
</div>

<div id="outline-container-org27dfca7" class="outline-3">
<h3 id="org27dfca7"><span class="section-number-3">2.14</span> Other</h3>
<div class="outline-text-3" id="text-2-14">
<p>
<i>Multivariate Adaptive Regression Splines (MARS)</i> is an adaptive
procedure for regression, and well suited for high-dimensional
problems. It can be viewed as generalization of step-wise linear
regression.
</p>
</div>
</div>
</div>

<div id="outline-container-org7613820" class="outline-2">
<h2 id="org7613820"><span class="section-number-2">3</span> Support Vector Machine</h2>
<div class="outline-text-2" id="text-3">
<p>
A linear hyperplane can separate classes, but there exists an infinite
number of such hyperplanes. There is a classifier called <i>Maximal
Margin Classifier</i>, also known as <i>optimal separating hyperplane</i>.
The separating hyperplane that is farthest from the training
observations.  That is, we can compute the (perpendicular) distance
from each training observation to a given separating hyperplane; the
smallest such distance is the minimal distance from the observations
to the hyperplane, and is known as the <i>margin</i>. The <i>maximal margin
hyperplane</i> is the separating hyperplane for which the margin is
largest—that is, it is the hyperplane that has the farthest minimum
dis- tance to the training observations.  The closest observations are
<i>support vectors</i>.  they “support” the maximal margin hyperplane in
the sense that if these points were moved slightly then the maximal
margin hyperplane would move as well.
</p>

<p>
However, the above classifier is not stable, and more importantly, it
is still linear decision boundary, and cannot be applied in
non-separable cases. Thus the <i>Support Vector Classifier (SVM)</i>, also
known as <i>soft margin classifier</i>, is introduce.  It the best “out of
the box” classifiers. It allows some observations to be on the
incorrect side of the margin, or even the incorrect side of the
hyperplane.
</p>

<p>
Some observations:
</p>
<ol class="org-ol">
<li>only observations that either lie on the margin or that violate the
margin will affect the hyperplane</li>
<li>an observation that lies strictly on the correct side of the margin
does not affect the support vector classifier</li>
<li>Observations that lie directly on the margin, or on the wrong side
of the margin for their class, are known as support vectors.</li>
<li>When the tuning parameter C is large, then the margin is wide</li>
</ol>

<p>
The support vector machine is a linear classifier, but it can be
extended into non-linear through using non-linear kernels. Kernel
trick is basis expansion.
</p>

<p>
linear kernel:
</p>

\begin{eqnarray}
K(x_i, x_{i'}) = \sum_{j=1}^p x_{ij} x_{i'j}
\end{eqnarray}

<p>
polynomial kernel:
</p>
\begin{eqnarray}
K(x_i, x_{i'}) = (1 + sum_{j=1}^p x_{ij} x_{i'j})^d
\end{eqnarray}

<p>
Radial kernel:
</p>
\begin{eqnarray}
K(x_i, x_{i'}) = exp(-\gamma \sum_{j=1}^p (x_{ij} - x{i'j})^2)
\end{eqnarray}

<p>
SVMs can be extended easily to more than 2 classes.  <i>One-versus-one
classification</i> computes all pairs SVMs, while <i>one-versus-all
classification</i> computes all one versus all other SVMs.
</p>
</div>
</div>


<div id="outline-container-org4e3a0ba" class="outline-2">
<h2 id="org4e3a0ba"><span class="section-number-2">4</span> Unsupervised Learning</h2>
<div class="outline-text-2" id="text-4">
<p>
<i>Unsupervised learning</i> is typically used for <i>Clustering</i>.
</p>
</div>

<div id="outline-container-org5a894f0" class="outline-3">
<h3 id="org5a894f0"><span class="section-number-3">4.1</span> K-means</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<i>K-means</i> method ensures the total within-cluster variation, summed
over all K clusters, is as small as possible.  It defines the
within-cluster variation.  The formula for it is: the sum of all of
the pairwise squared Euclidean distances between the observations in
the kth cluster. W(C<sub>k</sub>) depicts the amount by which the observations
within a cluster differ from each other
</p>

\begin{eqnarray}
W(C_k) = \frac{1}{|C_k|} \sum_{i,i' \in C_k} \sum_{j=1}^p (x_{ij} - x_{i'j})^2
\end{eqnarray}

<p>
where \(|C_k|\) denotes the number of observations in the kth cluster.
</p>

<p>
The algorithm:
</p>
<ol class="org-ol">
<li>select a number K, randomly assign a clustering from 1 to K for
each observation</li>
<li>iterate until cluster assignments stop changing
<ol class="org-ol">
<li>for each cluster, compute <i>centroid</i>: the vector of the p
features means for the observations in the kth cluster.</li>
<li>assign each observation to the cluster whose centroid is closest.</li>
</ol></li>
</ol>

<p>
This algorithm guarantee to decrease the objective formula above.
</p>
</div>
</div>

<div id="outline-container-orgcc11fcd" class="outline-3">
<h3 id="orgcc11fcd"><span class="section-number-3">4.2</span> Hierarchical Clustering</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The downside of K-mean is the need for predefined number of
clusters. <i>Hierarchical Clustering</i> does not predefine the number of
clusters.  The result is called a <i>dendrogram</i>, a tree-based
representation of the observations.
</p>

<p>
It is constructed bottom-up.  The tree node means a fusion.  The
height of the fusion indicates how different the two observations are.
Never compare the horizontal distance.  Construction algorithm:
examine all pairwise inter-cluster dissimilarities among all clusters.
Fuse the most similar ones.
</p>

<p>
The four most commonly used types of linkage:
</p>
<ul class="org-ul">
<li>complete: maximal intercluster dissimilarity</li>
<li>single: minimal intercluster dissimilarity</li>
<li>average: mean intercluster dissimilarity</li>
<li>centroid: dissimilarity between the centroid of cluster A and B</li>
</ul>
</div>
</div>
</div>
</div>
</body>
</html>
