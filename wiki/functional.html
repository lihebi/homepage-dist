<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Functional Programming</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/home/hebi/git/homepage/assets/org.css" /><link rel="stylesheet" type="text/css" href="/home/hebi/git/homepage/assets/hebi.css" /><link rel="stylesheet" type="text/css" href="/assets/org.css" /><link rel="stylesheet" type="text/css" href="/assets/hebi.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">Functional Programming</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org426d61d">1. References</a></li>
<li><a href="#orgfc14280">2. <span class="todo TODO">TODO</span> Haskell</a>
<ul>
<li><a href="#orgbd7e3d7">2.1. Tmp</a>
<ul>
<li><a href="#orgeb7ebbd">2.1.1. operators</a></li>
</ul>
</li>
<li><a href="#orgbf50894">2.2. references</a></li>
<li><a href="#org69809a5">2.3. layout</a></li>
<li><a href="#org0503860">2.4. lexical staff</a>
<ul>
<li><a href="#org9e1abb0">2.4.1. fixity declaration</a></li>
</ul>
</li>
<li><a href="#org01f7688">2.5. decl</a></li>
<li><a href="#orga30aebf">2.6. do expression</a></li>
<li><a href="#org4c33a3d">2.7. list comprehension</a></li>
<li><a href="#orgb293d81">2.8. function and lambda</a></li>
<li><a href="#orgb873060">2.9. let binding</a></li>
<li><a href="#orgf46105b">2.10. conditional</a></li>
<li><a href="#org940b179">2.11. case expression</a></li>
</ul>
</li>
<li><a href="#orgf465a19">3. Expression</a></li>
<li><a href="#org5d6313b">4. What is a Function?</a>
<ul>
<li><a href="#orgcaaddf2">4.1. Composition</a></li>
<li><a href="#orge7b9c9f">4.2. Strictness</a></li>
</ul>
</li>
<li><a href="#org5678daf">5. Type</a>
<ul>
<li><a href="#orgcb1ece0">5.1. Type inference</a></li>
<li><a href="#org05a7002">5.2. List</a></li>
</ul>
</li>
<li><a href="#orgcd445a5">6. Recursion</a></li>
</ul>
</div>
</div>

<div id="outline-container-org426d61d" class="outline-2">
<h2 id="org426d61d"><span class="section-number-2">1</span> References</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>introduction to functional programming <a class='org-ref-reference' href="#1988-Book-Bird-Introduction">1988-Book-Bird-Introduction</a></li>

<li><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types">product type vs. sum type</a>
<ul class="org-ul">
<li><i>algebraic data type</i> is a kind of composite type, i.e., a type formed by
combining other types.  Algebraic data type contains product type and sum type.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgfc14280" class="outline-2">
<h2 id="orgfc14280"><span class="section-number-2">2</span> <span class="todo TODO">TODO</span> Haskell</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgbd7e3d7" class="outline-3">
<h3 id="orgbd7e3d7"><span class="section-number-3">2.1</span> Tmp</h3>
<div class="outline-text-3" id="text-2-1">
<dl class="org-dl">
<dt>referentially transparent</dt><dd>we can replace any expression by its
value without changing the behaviour of the program.</dd>
</dl>

<p>
About Applicative and its relation with Monad
</p>
</div>

<div id="outline-container-orgeb7ebbd" class="outline-4">
<h4 id="orgeb7ebbd"><span class="section-number-4">2.1.1</span> operators</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Use <a href="https://hoogle.haskell.org/">Hoogle</a>
to search for operator symbols!
</p>
</div>

<ol class="org-ol">
<li><a id="orgc2b84f2"></a>list difference <code>(\\)</code><br />
<div class="outline-text-5" id="text-2-1-1-1">
<p>
The <code>(\\)</code> function is list difference (non-associative).  The result
of <code>xs \\ ys</code> is a smaller <code>xs</code>, with <code>ys</code> removed.
</p>
</div>
</li>

<li><a id="orgb3f74df"></a>strictness declaration<br />
<div class="outline-text-5" id="text-2-1-1-2">
<p>
From <a href="https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration">a stackoverflow question</a>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Foo</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Foo</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-constructor">Int</span> <span class="org-haskell-operator">!</span><span class="org-haskell-constructor">Int</span> <span class="org-haskell-operator">!</span>(<span class="org-haskell-constructor">Maybe</span> <span class="org-haskell-constructor">Int</span>)
</pre>
</div>
</div>
</li>

<li><a id="orgd205325"></a>infix operator <code>(+)</code> and <code>``</code><br />
<div class="outline-text-5" id="text-2-1-1-3">
<p>
Haskell functions ar typically used using prefix notation. However,
some operations are used infix, such as <code>+</code>. It is possible to use + in
prefix style, by putting it inside parenthesis <code>(+)</code>.
</p>

<p>
Additionally, putting backticks around normal prefix functions enables
you to use them as infix functions. It is typically used for
2-argument functions, but for more arguments, you need to use extra
parentheses.
</p>
</div>
</li>


<li><a id="org0058759"></a>as-pattern<br />
<div class="outline-text-5" id="text-2-1-1-4">
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">f</span> (x<span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">=</span> x<span class="org-haskell-constructor">:</span>x<span class="org-haskell-constructor">:</span>xs
<span class="org-haskell-definition">f</span> s<span class="org-haskell-operator">@</span>(x<span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">=</span> x<span class="org-haskell-constructor">:</span>s
</pre>
</div>
</div>
</li>

<li><a id="org02119d9"></a>tilde<br />
<div class="outline-text-5" id="text-2-1-1-5">
<p>
When using patten matching, a tilde makes two things:
</p>
<ul class="org-ul">
<li>force matching: you tell the compiler, trust me, this would
match. If not matching, it will result in runtime error.</li>
<li>lazy matching: the match does not happen until the value is used.</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell">head' <span class="org-haskell-definition">~</span>(x<span class="org-haskell-constructor">:</span>xs) <span class="org-haskell-operator">=</span> x
</pre>
</div>
</div>
</li>

<li><a id="org36148fe"></a>function composition<br />
<div class="outline-text-5" id="text-2-1-1-6">
<div class="org-src-container">
<pre class="src src-haskell">(f <span class="org-haskell-operator">.</span> g) x <span class="org-haskell-operator">=</span> f (g x)
</pre>
</div>

<p>
It has precedence 9.
</p>
</div>
</li>

<li><a id="org67d274d"></a>dollar operator<br />
<div class="outline-text-5" id="text-2-1-1-7">
<div class="org-src-container">
<pre class="src src-haskell">(<span class="org-haskell-definition">$</span>) <span class="org-haskell-operator">::</span> (a <span class="org-haskell-operator">-&gt;</span> b) <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> b
</pre>
</div>

<p>
$ has 0 precedence, the lowest. Thus it is used to change the order of
operator associativity. Also commonly used to separate large arguments.
</p>

<div class="org-src-container">
<pre class="src src-haskell">sort <span class="org-haskell-definition">$</span> <span class="org-string">"hello"</span> <span class="org-haskell-operator">++</span> <span class="org-string">"world"</span>
</pre>
</div>
</div>
</li>

<li><a id="orgb8fab51"></a>Lexical syntax:<br />
<div class="outline-text-5" id="text-2-1-1-8">
<dl class="org-dl">
<dt><code>=&gt;</code></dt><dd>context or class inheritance</dd>
</dl>
</div>
</li>

<li><a id="orgbacbb91"></a>Defined in Functor:<br />
<div class="outline-text-5" id="text-2-1-1-9">
<ul class="org-ul">
<li>&lt;$&gt;: fmap</li>
</ul>
</div>
</li>

<li><a id="org1663363"></a>Defined in Applicative:<br />
<div class="outline-text-5" id="text-2-1-1-10">
<ul class="org-ul">
<li>&lt;*&gt;: used with fmap</li>
<li>*&gt;: defined in Functor sequential stmts</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="orgcc7dc45"></a>(2008) Applicative programming with effects<br />
<div class="outline-text-6" id="text-2-1-1-10-1">
<p>
Applicative type class has the following methods:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">pure</span> <span class="org-haskell-operator">::</span> a <span class="org-haskell-operator">-&gt;</span> f aSource
(<span class="org-haskell-definition">&lt;*&gt;</span>) <span class="org-haskell-operator">::</span> f (a <span class="org-haskell-operator">-&gt;</span> b) <span class="org-haskell-operator">-&gt;</span> f a <span class="org-haskell-operator">-&gt;</span> f b
<span class="org-haskell-definition">liftA2</span> <span class="org-haskell-operator">::</span> (a <span class="org-haskell-operator">-&gt;</span> b <span class="org-haskell-operator">-&gt;</span> c) <span class="org-haskell-operator">-&gt;</span> f a <span class="org-haskell-operator">-&gt;</span> f b <span class="org-haskell-operator">-&gt;</span> f c
(<span class="org-haskell-definition">*&gt;</span>) <span class="org-haskell-operator">::</span> f a <span class="org-haskell-operator">-&gt;</span> f b <span class="org-haskell-operator">-&gt;</span> f b
(<span class="org-haskell-definition">&lt;*</span>) <span class="org-haskell-operator">::</span> f a <span class="org-haskell-operator">-&gt;</span> f b <span class="org-haskell-operator">-&gt;</span> f a
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="orgf264ca3"></a>Defined in Alternative<br />
<div class="outline-text-5" id="text-2-1-1-11">
<dl class="org-dl">
<dt><code>&lt;|&gt;</code></dt><dd><code>Nothing &lt;|&gt; Just a = Just a</code></dd>
</dl>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgbf50894" class="outline-3">
<h3 id="orgbf50894"><span class="section-number-3">2.2</span> references</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Haskell language report 2010 <a href="https://www.haskell.org/onlinereport/haskell2010/">https://www.haskell.org/onlinereport/haskell2010/</a></li>
<li>Haskell book, a good tutorial <a href="https://en.wikibooks.org/wiki/Haskell">https://en.wikibooks.org/wiki/Haskell</a></li>
<li>A Gentle Introduction to Haskell, Version 98 <a href="https://www.haskell.org/tutorial/index.html">https://www.haskell.org/tutorial/index.html</a></li>
</ul>
</div>
</div>


<div id="outline-container-org69809a5" class="outline-3">
<h3 id="org69809a5"><span class="section-number-3">2.3</span> layout</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Layout is optional:
</p>

<blockquote>
<p>
Haskell <b>permits the omission of the braces and semicolons</b> used in
several grammar productions, by using layout to convey the same
information. This allows both layout-sensitive and layout-insensitive
styles of coding, which can be <b>freely mixed</b> within one program.
</p>
</blockquote>

<p>
Formal layout rules:
</p>

<blockquote>
<p>
The layout (or “off-side”) rule takes effect whenever the <span class="underline">open brace
is omitted</span> after the keyword <code>where</code>, <code>let</code>, <code>do</code>, or <code>of</code>. When this
happens, the indentation of the next lexeme (whether or not on a new
line) is remembered and the omitted <span class="underline">open brace is inserted</span> (the
whitespace preceding the lexeme may include comments).
</p>

<p>
For each subsequent line,
</p>
<ul class="org-ul">
<li>if it contains only whitespace or is <span class="underline">indented more</span>, then the
previous item is continued (nothing is inserted);</li>
<li>if it is <span class="underline">indented the same</span> amount, then a new item begins (a
<span class="underline">semicolon is inserted</span>);</li>
<li>and if it is <span class="underline">indented less</span>, then the layout list ends (a <span class="underline">close
brace is inserted</span>).</li>
<li>If the indentation of the non-brace lexeme immediately following a
<code>where</code>, <code>let</code>, <code>do</code> or <code>of</code> is <span class="underline">less than or equal to</span> the current
indentation level, then instead of starting a layout, an empty list
<span class="underline">“{}” is inserted</span>, and layout processing occurs for the current
level (i.e. insert a semicolon or close brace)</li>
</ul>
</blockquote>

<p>
Explicit open brace must be closed explicitly:
</p>
<blockquote>
<p>
The layout rule matches only those open braces that it has inserted;
<span class="underline">an explicit open brace must be matched by an explicit close
brace</span>. Within these explicit open braces, no layout processing is
performed for constructs outside the braces, even if a line is
indented to the left of an earlier implicit open brace.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org0503860" class="outline-3">
<h3 id="org0503860"><span class="section-number-3">2.4</span> lexical staff</h3>
<div class="outline-text-3" id="text-2-4">
<p>
precedence and associative:
</p>
<blockquote>
<p>
Consecutive unparenthesized operators with the same precedence must
both be either left or right associative to avoid a syntax error.
</p>
</blockquote>

<p>
<code>lambda</code>, <code>let</code>, conditionals extend as far to the right as possible:
</p>
<blockquote>
<p>
The grammar is ambiguous regarding the extent of lambda abstractions,
let expressions, and conditionals. The ambiguity is resolved by the
meta-rule that each of these constructs extends as far to the right as
possible.
</p>
</blockquote>
</div>

<div id="outline-container-org9e1abb0" class="outline-4">
<h4 id="org9e1abb0"><span class="section-number-4">2.4.1</span> fixity declaration</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Determines the binding precedence of an operator. A fixity declaration
may appear anywhere that a type signature appears.
</p>

<blockquote>
<p>
There are three kinds of fixity, non-, left- and right-associativity
(infix, infixl, and infixr, respectively), and ten precedence levels,
0 to 9 inclusive <span class="underline">(level 0 binds least tightly, and level 9 binds most
tightly)</span>. If the digit is omitted, level 9 is assumed. Any operator
lacking a fixity declaration is assumed to be <span class="underline">infixl 9 by default</span>.
</p>
</blockquote>

<p>
There is a table for all operators and their precedence levels.
</p>
</div>
</div>
</div>

<div id="outline-container-org01f7688" class="outline-3">
<h3 id="org01f7688"><span class="section-number-3">2.5</span> decl</h3>
<div class="outline-text-3" id="text-2-5">
<p>
var :: type
</p>
</div>
</div>

<div id="outline-container-orga30aebf" class="outline-3">
<h3 id="orga30aebf"><span class="section-number-3">2.6</span> do expression</h3>
<div class="outline-text-3" id="text-2-6">
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">do</span>
  stmt
  <span class="org-comment-delimiter">-- </span><span class="org-comment">stmt can be</span>
  pat
  pat <span class="org-haskell-operator">&lt;-</span> exp
  <span class="org-comment-delimiter">-- </span><span class="org-comment">this is not the let expression. The binding will take effect in</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">the following program</span>
  <span class="org-haskell-keyword">let</span> decls
  <span class="org-comment-delimiter">-- </span><span class="org-comment">the last one must be an expression, and cannot have pattern binding</span>
  exp
</pre>
</div>
</div>
</div>



<div id="outline-container-org4c33a3d" class="outline-3">
<h3 id="org4c33a3d"><span class="section-number-3">2.7</span> list comprehension</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">
<pre class="src src-haskell">[x <span class="org-haskell-operator">|</span> xs <span class="org-haskell-operator">&lt;-</span> [[(1,2),(3,4)],
            [(5,4),(3,2)]],
     (3,x) <span class="org-haskell-operator">&lt;-</span> xs]
</pre>
</div>

<p>
<code>&lt;-</code> is generator syntax, and nested. Each iteration, if a value does
not match, that value is <b>skipped</b>. Thus the above expression
evaluates to <code>[4,2]</code>
</p>

<p>
In general in Haskell, <code>&lt;-</code> will perform patern matching with left
being pattern.
</p>
</div>
</div>

<div id="outline-container-orgb293d81" class="outline-3">
<h3 id="orgb293d81"><span class="section-number-3">2.8</span> function and lambda</h3>
<div class="outline-text-3" id="text-2-8">
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">double</span> x <span class="org-haskell-operator">=</span> x <span class="org-haskell-operator">*</span> x
  <span class="org-haskell-keyword">where</span> decls
<span class="org-haskell-operator">\</span> x y <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> y
</pre>
</div>

<p>
function
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">funlhs</span> var <span class="org-haskell-operator">=</span> exp <span class="org-haskell-keyword">where</span> decls
<span class="org-haskell-definition">funlhs</span> var
  <span class="org-haskell-operator">|</span> guard <span class="org-haskell-operator">=</span> exp
  <span class="org-comment-delimiter">-- </span><span class="org-comment">three types of guards</span>
  <span class="org-haskell-operator">|</span> (3,x) <span class="org-haskell-operator">&lt;-</span> exp <span class="org-haskell-operator">=</span> exp
  <span class="org-haskell-operator">|</span> <span class="org-haskell-keyword">let</span> decls <span class="org-haskell-operator">=</span> exp
  <span class="org-haskell-operator">|</span> boolexp <span class="org-haskell-operator">=</span> exp
  <span class="org-haskell-keyword">where</span> decls
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb873060" class="outline-3">
<h3 id="orgb873060"><span class="section-number-3">2.9</span> let binding</h3>
<div class="outline-text-3" id="text-2-9">
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">let</span> x, y <span class="org-haskell-operator">=</span> 5,10 <span class="org-haskell-keyword">in</span> x <span class="org-haskell-operator">+</span> y <span class="org-haskell-operator">+</span> 1
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf46105b" class="outline-3">
<h3 id="orgf46105b"><span class="section-number-3">2.10</span> conditional</h3>
<div class="outline-text-3" id="text-2-10">
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">if</span> e1 <span class="org-haskell-keyword">then</span> e2 <span class="org-haskell-keyword">else</span> e3
</pre>
</div>
</div>
</div>

<div id="outline-container-org940b179" class="outline-3">
<h3 id="org940b179"><span class="section-number-3">2.11</span> case expression</h3>
<div class="outline-text-3" id="text-2-11">
<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">case</span> exp <span class="org-haskell-keyword">of</span> {
  pat <span class="org-haskell-operator">-&gt;</span> exp <span class="org-haskell-keyword">where</span> decls
  <span class="org-comment-delimiter">-- </span><span class="org-comment">equivalent to</span>
  pat <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">True</span> <span class="org-haskell-operator">-&gt;</span> exp

  pat <span class="org-haskell-operator">|</span> guard <span class="org-haskell-keyword">where</span> decls
  <span class="org-comment-delimiter">-- </span><span class="org-comment">which has three kinds of guards</span>
  pat <span class="org-haskell-operator">|</span> (3,x) <span class="org-haskell-operator">&lt;-</span> exp
  pat <span class="org-haskell-operator">|</span> <span class="org-haskell-keyword">let</span> decls
  pat <span class="org-haskell-operator">|</span> boolexp
}
</pre>
</div>
</div>
</div>
</div>









<div id="outline-container-orgf465a19" class="outline-2">
<h2 id="orgf465a19"><span class="section-number-2">3</span> Expression</h2>
<div class="outline-text-2" id="text-3">
<p>
An expression can be <i>reduced</i> to an simpler equivalent form.  We say
an expression is <i>canonical</i> (or in <i>normal form</i>) if it cannot be
further reduced.
</p>

<p>
The result of <i>equality test</i> is done by reducing the expressions to
their canonical form, and testing whether the results are
identical. If an expression does not have a canonical form, the result
is undefined, represented by \(\bot\). In particular, function values
have no canonical form.
</p>

<p>
The order of evaluation thus matters. Each reduction step replace a
sub-term by an equivalent term. The term is called a <i>redex</i>, short
for <i>reducible expression</i>. There are two reduction policies,
<i>innermost reduction</i> and <i>outermost reduction</i>. <i>Innermost reduction</i>
reduces the innermost redex, i.e. the one that contains no other
redex. <i>Outermost reduction</i> reduces the one that is contained in no
other redex.
</p>

<p>
Any term that is reduced must be reduced to <i>head normal form</i>. A term
is in <i>head normal form</i> if it is not a redex, and it cannot become a
redex by reducing any of its subterms. For example, <code>(e1:e2)</code> is in
head normal form, because the (:) <i>itself</i> cannot be reduced. However,
<code>e1</code> and <code>e2</code> might be reducible. It is a normal form only when e1 and
e2 both are in normal form. By definition, every term in normal form
is in head normal form, but not vice versa.
</p>

<p>
The evaluation order matters because of the <i>termination</i>. Sometimes,
the outermost reduction will terminate while the inner most fail to do
so. In fact, we have the following property:
</p>

<blockquote>
<p>
For every term, if there exists any reduction order that terminates,
then there is an outermost reduction that terminates.
</p>
</blockquote>

<p>
Thus, outermost reduction is also called <i>normal order reduction</i>,
because it is capable of reducing a term to its normal form whenever
the term has such a form. It is also called <i>lazy evaluation</i>, because
it does not reduce a term unless it is essential for finding the
answer. By contract, the innermost reduction is called <i>applicative
order reduction</i>, or <i>eager evaluation</i>.
</p>

<p>
Outermost reduction is essential for evaluating non-strict
functions. But innermost and outermost reduction will yield the same
answer when only strict functions are involved.
</p>

<p>
With that said for termination property, however, outermost may
require more steps than innermost reduction. The reason is that, the
outermost reduction might duplicate some inner expressions. One
problem is called <i>graph reduction</i>, which ensures that the duplicated
sub-terms are always linked together in the graph, and reduction of
them will happen ones, for all the references of them. With graph
reduction, we can say outermost reduction never performs more steps
than innermost.
</p>

<p>
In summary, we shall use <i>outermost graph reduction</i> as the evaluation
model, because
</p>
<ol class="org-ol">
<li>it terminates whenever any reduction order terminates</li>
<li>it requires no more steps than innermost order reduction</li>
</ol>

<p>
However, the outermost reduction might use more space than
innermost. In this case, it might be desired to mix innermost order to
achieve better space efficiency. There is a special function <code>strict</code>
that fine-control the evaluation order. <code>strict f e</code> is reduced by
first reducing <code>e</code> to head normal form, then applying <code>f</code>. The term
<code>e</code> itself is evaluated as normal, using outermost order. With that,
<code>strict</code> can be defined like below. We can easily have this: <code>f =
strict f</code> iff <code>f</code> is a strict function.
</p>

<pre class="example">
strict f x = \bot, if x = \bot
           = f x,  otherwise
</pre>

<p>
There are some ways to decide how to use <code>strict</code> to optimize the
space occupation, but some takeaway: for functions such as <code>(+)</code> or
<code>(x)</code>, that are strict in <b>both arguments</b>, and can be computed in
constant time and space, <code>foldl'</code> is more efficient. But for
functions, such as <code>(&amp;)</code> and <code>(++)</code>, that are non-strict in some
argument, <code>foldr</code> is often more efficient.  (<code>foldl'</code> is a rewrite of
<code>foldl</code> with strictness)
</p>

<pre class="example">
foldl' (op) a [] = a
foldl' (op) a (x:xs) = strict (foldl' (op)) (a op x) xs
</pre>
</div>
</div>



<div id="outline-container-org5d6313b" class="outline-2">
<h2 id="org5d6313b"><span class="section-number-2">4</span> What is a Function?</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>currying: replacing structured arguments by a sequence of simple
ones. The function application operation associates to the left,
i.e. <code>f x y</code> means <code>((f x) y)</code>.</li>
</ul>
</div>

<div id="outline-container-orgcaaddf2" class="outline-3">
<h3 id="orgcaaddf2"><span class="section-number-3">4.1</span> Composition</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Functional composition has the definition of
</p>

<p>
\[(f \circ g) x = f (g x)\]
</p>

<p>
and the type of it
</p>

<p>
\[(\circ) :: (\beta \rightarrow \gamma) \rightarrow (\alpha
\rightarrow \beta) \rightarrow (\alpha \rightarrow \gamma)\]
</p>

<p>
functional composition is also associative, thus no need to put
brackets
</p>

<p>
\[(f \circ g) \circ h = f \circ (g \circ h)\]
</p>
</div>
</div>

<div id="outline-container-orge7b9c9f" class="outline-3">
<h3 id="orge7b9c9f"><span class="section-number-3">4.2</span> Strictness</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The special value \(\bot\) is polymorphic: \(\bot\) is a value of every
type. This means, any function can be applied to \(\bot\). If \(f \bot =
\bot\), then \(f\) is said to be strict. Otherwise, it is non-strict. In
other words, a function is <i>strict</i> if it is undefined whenever its
argument is undefined.
</p>


<p>
In fact, a non-strict semantic is often preferable for functions, for
several reasons:
</p>
<ul class="org-ul">
<li>it makes reasoning about equality easier</li>
<li>we can define new control structures by defining new functions</li>
</ul>

<p>
For example, we define a function <code>three</code> that takes anything and
return the value <code>3</code>. I.e.
</p>

<pre class="example">
three :: num -&gt; num
three x = 3
</pre>

<p>
Another example, the definition of <code>cond</code>
</p>

<p>
\[cond :: bool \rightarrow \alpha \rightarrow \alpha \rightarrow \alpha\]
</p>

<pre class="example">
cond p x y = x, if p
           = y, otherwise
</pre>

<p>
Under strict semantics, \(cond\ True\ 0\ \bot = \bot\), under non-strict
semantics, \(cond True 0 \bot = 0\). But in either case, <code>cond</code> is
strict on its first argument. This also means, strictness is bundled
with the function, and is applied on some arguments, not all.
</p>

<p>
The operational semantics of strict or non-strict functions is closely
related to the reduction strategy. <i>eager-evaluation</i> reduces every
expression to its simplest form, while <i>lazy-evaluation</i> does not care
about the wellness of the expressions whose values are not required
for the evaluation.
</p>
</div>
</div>
</div>

<div id="outline-container-org5678daf" class="outline-2">
<h2 id="org5678daf"><span class="section-number-2">5</span> Type</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Strong-typing: the type of an expression depends only on the type of
its component expressions.</li>
<li>Type variable: typically represented in Greek letters \(\alpha\),
\(\beta\), etc. Such type can be instantiated by substitute the type
variable with specific type.</li>
<li>Polymorphic type: a type that contains <i>type variables</i></li>
<li>Enumerated type: enumeration of possible values</li>
<li>Composite type: composite primitive type together to form new types</li>
<li>algebraic data type: is a form of composite type, containing product
type and sum type
<ul class="org-ul">
<li>sum type: this is like C union, so it is also called a tagged
union. It can take value of either the type, but not both.</li>
<li>product type: this is like a C structure with different
fields. The value set of this type is the set-theoretic product,
i.e., the Cartesian product of the set of the field type.</li>
</ul></li>
<li>Abstract Type: types in which the values are prescribed, but the
operations are not, are called concrete types. A type whose values
are not defined, but operations are, is called abstract type.</li>
</ul>
</div>

<div id="outline-container-orgcb1ece0" class="outline-3">
<h3 id="orgcb1ece0"><span class="section-number-3">5.1</span> Type inference</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Three basic rules
</p>

<ol class="org-ol">
<li>Application rule: if <code>f x :: t</code>, then <code>x :: t'</code> and <code>f :: t' -&gt; t</code>
for some new type <code>t'</code></li>
<li>Equality rule: if both the types <code>x :: t</code> and <code>x :: t'</code> can be
deduced for a variable <code>x</code>, then <code>t = t'</code>.</li>
<li>Function rule: If <code>t -&gt; u = t' -&gt; u'</code>, then <code>t = t'</code>, and <code>u = u'</code></li>
</ol>

<p>
Often, the newly introduced types are named by numerical sub-notation.
</p>

<p>
For example, consider the composition operator
</p>

<pre class="example">
(.) f g x = f (g x)
</pre>

<p>
The following script shows the inference steps:
</p>
<pre class="example">
f :: t1
g :: t2
x :: t3
f (g x) :: t4
(.) :: t1 -&gt; t2 -&gt; t3 -&gt; t4
g x :: t5
f :: t5 -&gt; t4
x :: t6
g :: t6 -&gt; t5
t1 = t5 -&gt; t4
t2 = t6 -&gt; t5
t3 = t6
(.) :: (t5 -&gt; t4) -&gt; (t6 -&gt; t5) -&gt; t6 -&gt; t4
</pre>

<p>
Finally, we need to replace the types with type variables to make it
generic:
</p>

<p>
\[(\circ) :: (\beta \rightarrow \gamma) \rightarrow (\alpha
\rightarrow \beta) \rightarrow (\alpha \rightarrow \gamma)\]
</p>
</div>
</div>

<div id="outline-container-org05a7002" class="outline-3">
<h3 id="org05a7002"><span class="section-number-3">5.2</span> List</h3>
<div class="outline-text-3" id="text-5-2">
<p>
List itself is defined as a recursive type.
</p>

<p>
\[list \alpha :: Nil | Cons \alpha (list \alpha)\]
</p>


<p>
Let list comprehension notation be <code>[&lt;expr&gt; | &lt;qualifier&gt;;
...]</code>. Qualifier can be boolean expression for predicates or
generators. Later generators vary more quickly than their
predecessors, and can depends on the variables introduced by earlier
ones. With this, we can define many operators on lists:
</p>

<pre class="example">
(++) :: [a] -&gt; [a] -&gt; [a]
concat :: [[a]] -&gt; [a]
concat xss = [x | xs &lt;- xss; x &lt;- xs]
</pre>

<p>
Instead of using <code>(++)</code> for concating list, we can use <code>(:)</code>
(pronounced 'cons') for specifying consing. One important reason to
use <code>(:)</code> is that, every list can be expressed in terms of <code>[]</code> and
<code>(:)</code> in <b>exactly one way</b>.
</p>

<pre class="example">
(:) :: a -&gt; [a] -&gt; [a]
x:xs = [x] ++ xs
</pre>

<p>
We have the following operators on lists:
</p>
<pre class="example">

(#) :: [a] -&gt; num
#(xs ++ ys) = #xs + #ys

hd :: [a] -&gt; a
tl :: [a] -&gt; [a]
hd ([x] ++ xs) = x
tl ([x] ++ xs) = xs

take n xs ++ drop n xs = xs

takewhile :: (a -&gt; bool) -&gt; [a]  -&gt; [a]
zip :: ([a], [b]) -&gt; [(a,b)]
(!) :: [a] -&gt; num -&gt; a # index

</pre>

<p>
Map and filter can be defined by:
</p>
<pre class="example">
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map f xs = [f x | x &lt;- xs]
filter :: (a -&gt; bool) -&gt; [a] -&gt; [a]
filter p xs = [x | x &lt;- xs; p x]
</pre>

<p>
Fold:
</p>
<pre class="example">
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
sum = foldr (+) 0
product = foldr (x) 1
concat = foldr (++) []
and = foldr (&amp;) True
or = foldr (|) False
</pre>

<p>
<code>foldr</code> and <code>foldl</code> do rely on associative of the underlying operators
to function correctly, and there are several <i>duality theorems</i>.
</p>

<p>
In big data literature, <i>map</i> and <i>reduce</i> are borrowed from
functional programming. Map is just map, reduce has another familiar
name called <i>fold</i>.  The Map-reduce framework does not just borrow the
name. Its contribution is <b>scalability and fault-tolerance</b>. In this
case, <i>map</i> produces data by filtering, and emit the data,
marshalling, and <i>reduce</i> does folding.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcd445a5" class="outline-2">
<h2 id="orgcd445a5"><span class="section-number-2">6</span> Recursion</h2>
<div class="outline-text-2" id="text-6">
<p>
Functions are often defined recursively. In this section, we see some
of the list function definitions in recursion.
</p>

<pre class="example">
zip([], ys) = []
zip(x:xs, []) = []
zip(x:xs, y:ys) = (x,y):zip(xs,ys)
</pre>

<pre class="example">
take 0 xs = []
take (n+1) [] = []
take (n+1) (x:xs) = x:take n xs

drop 0 xs = xs
drop (n+1) [] = []
drop (n+1) (x:xs) = drop n xs
</pre>

<pre class="example">
hd(x:xs) = x
tl(x:xs) = xs
</pre>

<pre class="example">
map f [] = []
map f (x:xs) = f x : map f xs
filter p [] = []
filter p (x:xs) = x : filter p xs, if p x
                = filter p xs,     otherwise
</pre>

<p>
<h1 class='org-ref-bib-h1'>Bibliography</h1>
<ul class='org-ref-bib'><li><a id="1988-Book-Bird-Introduction">[1988-Book-Bird-Introduction]</a> <a name="1988-Book-Bird-Introduction"></a>Bird & Wadler, Introduction to Functional Programming, (1988).</li>
</ul>
</p>
</div>
</div>
</div>
</body>
</html>
