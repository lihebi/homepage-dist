<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algorithm</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/assets/org.css" /><link rel="stylesheet" type="text/css" href="/assets/hebi.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">Algorithm</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf118021">1. Basics</a>
<ul>
<li><a href="#orgfdfdb4e">1.1. Order of growth</a></li>
<li><a href="#org4a6d03b">1.2. <span class="todo TODO">TODO</span> how to analyze the running time</a></li>
<li><a href="#org2202cb5">1.3. <span class="todo TODO">TODO</span> Amortized Analysis</a></li>
</ul>
</li>
<li><a href="#org3ed6fd9">2. Sorting algorithms</a>
<ul>
<li><a href="#orgda97112">2.1. Bubble sort</a></li>
<li><a href="#orgaaf5516">2.2. insertion sort</a></li>
<li><a href="#org1d2a004">2.3. merge sort</a></li>
<li><a href="#org7b4560b">2.4. Heap sort</a></li>
<li><a href="#org1b2bbea">2.5. Quick sort</a></li>
<li><a href="#orgd7907e4">2.6. Linear time sorting</a>
<ul>
<li><a href="#org60a70bd">2.6.1. couting sort</a></li>
<li><a href="#org02bdc8b">2.6.2. <span class="todo TODO">TODO</span> Radix sort</a></li>
<li><a href="#org1171497">2.6.3. <span class="todo TODO">TODO</span> Bucket sort</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org13a6f70">3. Data structure</a>
<ul>
<li><a href="#org9be75a4">3.1. linked list</a></li>
<li><a href="#orge528e79">3.2. stack &amp; queue</a>
<ul>
<li><a href="#org038d5f3">3.2.1. priority queue</a></li>
</ul>
</li>
<li><a href="#org5ff99d4">3.3. hash table</a></li>
</ul>
</li>
<li><a href="#org580f576">4. Trees</a>
<ul>
<li><a href="#org94b4a37">4.1. Search</a></li>
<li><a href="#orgdc41ce2">4.2. Traversal</a></li>
<li><a href="#org6a98ed9">4.3. Special Trees</a>
<ul>
<li><a href="#org9fe3845">4.3.1. Binary search tree</a></li>
<li><a href="#org2382251">4.3.2. red-black tree</a></li>
<li><a href="#org29cf993">4.3.3. interval tree</a></li>
<li><a href="#org49c8bec">4.3.4. B-tree</a></li>
<li><a href="#orge73d714">4.3.5. prefix-tree</a></li>
</ul>
</li>
<li><a href="#org70e78b2">4.4. Heap</a>
<ul>
<li><a href="#org30aa066">4.4.1. <span class="todo TODO">TODO</span> Fibonacci Heap</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org009bfc2">5. Graph</a>
<ul>
<li><a href="#org3d0f218">5.1. DFS &amp; BFS</a></li>
<li><a href="#org80f462b">5.2. topological sort</a></li>
<li><a href="#orgcdc6d9f">5.3. Minimum Spanning Tree</a>
<ul>
<li><a href="#org64c794b">5.3.1. Kruskal's algorithm</a></li>
<li><a href="#orgebc825f">5.3.2. Prim's algorithm</a></li>
</ul>
</li>
<li><a href="#org766343f">5.4. Shortest path</a>
<ul>
<li><a href="#orgd60e0ac">5.4.1. Bellman-Ford algorithm</a></li>
<li><a href="#org6f7e7c6">5.4.2. Dijkstra's algorithm</a></li>
</ul>
</li>
<li><a href="#orga1754da">5.5. Network Flow Problems</a>
<ul>
<li><a href="#org9280772">5.5.1. Ford-Fulkerson method</a></li>
<li><a href="#orgdb5b754">5.5.2. Edmonds-Karp algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7c76cff">6. <span class="todo TODO">TODO</span> String algorithms</a>
<ul>
<li><a href="#orgb0108ee">6.1. <span class="todo TODO">TODO</span> Substring matching</a></li>
<li><a href="#orga3d62da">6.2. <span class="todo TODO">TODO</span> Rabin-Karp algorithm</a></li>
<li><a href="#org4b74537">6.3. <span class="todo TODO">TODO</span> Knuth-Morris-Pratt algorithm</a></li>
</ul>
</li>
<li><a href="#org1f6c8f4">7. <span class="todo TODO">TODO</span> Dynamic Programming</a>
<ul>
<li><a href="#org37d1df9">7.1. The rod-cutting problem</a></li>
<li><a href="#orgf259a87">7.2. <span class="todo TODO">TODO</span> Largest common subsequence</a></li>
</ul>
</li>
<li><a href="#orgf3ad410">8. Other Named Algorithm</a>
<ul>
<li><a href="#org469d3df">8.1. Bloom Filter</a></li>
</ul>
</li>
<li><a href="#org552d1ff">9. <span class="todo TODO">TODO</span> NP-Completeness</a>
<ul>
<li><a href="#orgb5676d0">9.1. Approximation algorithms</a>
<ul>
<li><a href="#org2699a76">9.1.1. the vertex-cover problem</a></li>
<li><a href="#org283aa51">9.1.2. the traveling-salesman problem</a></li>
<li><a href="#orga5cb8e9">9.1.3. the set-covering problem</a></li>
<li><a href="#orge26eecb">9.1.4. the subset-sum problem</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6fec13e">10. <span class="todo TODO">TODO</span> Linear Programming (LP)</a>
<ul>
<li><a href="#orgca2098b">10.1. Standard and slack forms</a></li>
<li><a href="#org6593bb1">10.2. Formulating</a></li>
<li><a href="#orgacebaea">10.3. Simplex algorithm</a></li>
<li><a href="#orga37e185">10.4. Duality</a></li>
</ul>
</li>
<li><a href="#org976450e">11. Tips</a>
<ul>
<li><a href="#org7ce18e6">11.1. <span class="todo TODO">TODO</span> Devide-and-Conquer</a></li>
<li><a href="#orga5f2524">11.2. Recursive</a></li>
<li><a href="#org2377596">11.3. Dynamic Programming</a></li>
</ul>
</li>
<li><a href="#org1eaa3d2">12. Old Writings</a>
<ul>
<li><a href="#org1a43fa9">12.1. Barrel shifter</a>
<ul>
<li><a href="#org4e6bd0f">12.1.1. shift register</a></li>
</ul>
</li>
<li><a href="#orge29b732">12.2. Linear congruential generator</a></li>
<li><a href="#org461937a">12.3. Dynamic Programming</a>
<ul>
<li><a href="#org42cfcfc">12.3.1. One dimension</a>
<ul>
<li><a href="#orgae06871">12.3.1.1. Define sub-problems</a></li>
<li><a href="#org209641c">12.3.1.2. Recurrence formula</a></li>
</ul>
</li>
<li><a href="#org355aa34">12.3.2. Two Dimensions</a>
<ul>
<li><a href="#orgc34b2b0">12.3.2.1. Define sub-problems</a></li>
<li><a href="#org4c35e09">12.3.2.2. Recurrence formula</a></li>
</ul>
</li>
<li><a href="#org042660c">12.3.3. Interval DP</a>
<ul>
<li><a href="#orgee99c88">12.3.3.1. Define sub-problem</a></li>
<li><a href="#org0146c3b">12.3.3.2. Recurrence formula</a></li>
</ul>
</li>
<li><a href="#org8401f07">12.3.4. Tree DP</a>
<ul>
<li><a href="#org031b87f">12.3.4.1. Define</a></li>
<li><a href="#org9f2ec08">12.3.4.2. Recurrence</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org508f6d0">12.4. String Algorithm</a>
<ul>
<li><a href="#org4a25499">12.4.1. Knuth–Morris–Pratt(KMP)</a>
<ul>
<li><a href="#org3dbbc13">12.4.1.1. 214. Shortest Palindrome</a></li>
</ul>
</li>
<li><a href="#org57a92eb">12.4.2. Boyer Moore</a>
<ul>
<li><a href="#orgd22a9d7">12.4.2.1. Bad Character Rule</a></li>
<li><a href="#orgaa46848">12.4.2.2. Good Suffix Rule</a></li>
<li><a href="#org38c44ec">12.4.2.3. Galil Rule</a></li>
</ul>
</li>
<li><a href="#org908c075">12.4.3. Rabin-Karp Algorithm</a>
<ul>
<li><a href="#orgd9a8c38">12.4.3.1. Rolling Hash</a></li>
<li><a href="#orga1226ab">12.4.3.2. Tabulation hashing</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
cite:2009-Book-Cormen-Introduction
</p>

<div id="outline-container-orgf118021" class="outline-2">
<h2 id="orgf118021"><span class="section-number-2">1</span> Basics</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgfdfdb4e" class="outline-3">
<h3 id="orgfdfdb4e"><span class="section-number-3">1.1</span> Order of growth</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In this section, &exist; c<sub>1,c</sub><sub>2,n</sub><sub>0</sub> means there exists positive
constants c<sub>1</sub>, c<sub>2</sub>, and n<sub>0</sub>.
</p>

<ul class="org-ul">
<li>\(\Theta (g(n))\): "big-theta" of g of n, both lower bound and upper
  bound, asymptotically tight bound</li>
<li>O: <b>big-o (most often used)</b>, upper bound, asymptotic upper bound</li>
<li>\(\Omega\): big omega, lower bound, asymptotic lower bound</li>
<li>o: little-o, not tight upper bound</li>
<li>\(\omega\): little omega, not tight lower bound</li>
</ul>

<p>
Formally:
</p>
<ul class="org-ul">
<li>\(\Theta(g(n)) = {f(n) : \exists c_1, c_2, n_0 \text{ such that } 0 \le c_1
  g(n) \le f(n) \le c_2 g(n) \text{ for all } n \ge n_0}\)</li>
<li>O(g(n)) = {f(n): &exist; c and n<sub>0</sub> such that 0 &le; f(n) &le; c g(n)
  for all n &ge; n<sub>0</sub>}</li>
<li>&Omega;(g(n)) = {f(n): &exist; c and n<sub>0</sub> such that 0 &le; c g(n) &le;
  f(n) for all n &ge; n<sub>0</sub>}</li>
<li>o(g(n)) = {f(n): &exist; c and n<sub>0</sub> such that 0 &le; f(n) &lt; c g(n) for
  all n &ge; n<sub>0</sub>}</li>
<li>&omega;(g(n)) = {f(n): &exist; c and n<sub>0</sub> such that 0 &le; c g(n) &lt;
  f(n) for all n &ge; n<sub>0</sub>}</li>
</ul>
</div>
</div>





<div id="outline-container-org4a6d03b" class="outline-3">
<h3 id="org4a6d03b"><span class="section-number-3">1.2</span> <span class="todo TODO">TODO</span> how to analyze the running time</h3>
</div>
<div id="outline-container-org2202cb5" class="outline-3">
<h3 id="org2202cb5"><span class="section-number-3">1.3</span> <span class="todo TODO">TODO</span> Amortized Analysis</h3>
</div>
</div>

<div id="outline-container-org3ed6fd9" class="outline-2">
<h2 id="org3ed6fd9"><span class="section-number-2">2</span> Sorting algorithms</h2>
<div class="outline-text-2" id="text-2">
<table border="2" cellspacing="2" cellpadding="6" rules="groups" frame="border">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">algorithm</th>
<th scope="col" class="org-left">worst-case</th>
<th scope="col" class="org-left">average case</th>
<th scope="col" class="org-left">memory</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">insertion sort</td>
<td class="org-left">n<sup>2</sup></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">merge sort</td>
<td class="org-left">n log n</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">heap sort</td>
<td class="org-left">n log n</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">in place</td>
</tr>

<tr>
<td class="org-left">quick sort</td>
<td class="org-left">n<sup>2</sup></td>
<td class="org-left">n log n</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">counting sort</td>
<td class="org-left">n+k</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">radix sort</td>
<td class="org-left">d(n+k)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">bucket sort</td>
<td class="org-left">n<sup>2</sup></td>
<td class="org-left">n</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgda97112" class="outline-3">
<h3 id="orgda97112"><span class="section-number-3">2.1</span> Bubble sort</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Go through the array n items. Each time, swap two adjacent items a and
b if a&gt;b. Each loop, the largest one go to the end, the smaller ones
bubbles up.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n-i):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">if</span> A[j] &gt; A[j+1]:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> swap(A[j], A[j+1])</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaaf5516" class="outline-3">
<h3 id="orgaaf5516"><span class="section-number-3">2.2</span> insertion sort</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Each loop, make sure the first i items are sorted. In the i-th loop,
insert the i-th item into the correct position.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">for</span> i <span class="org-keyword">in</span> 1 to A.length:</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">key</span> = A[i]</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">j</span> = i-1</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">while</span> A[j] &gt; key:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">A</span>[j+1] = A[j]</code>
<code><span class="org-highlight-indentation"> </span>   j--</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">A</span>[j]=key</code>
</pre>
</div>
</div>
</div>


<div id="outline-container-org1d2a004" class="outline-3">
<h3 id="org1d2a004"><span class="section-number-3">2.3</span> merge sort</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Uses divide-and-conquer, recursively solve the left and right
subarray, and merge the two sorted arrays (in linear time).
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">sort</span>(A, p, r):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">if</span> p &lt; r:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">q</span> = (p + r) / 2</code>
<code><span class="org-highlight-indentation"> </span>   sort(A, p, q)</code>
<code><span class="org-highlight-indentation"> </span>   sort(A, q, r)</code>
<code><span class="org-highlight-indentation"> </span>   merge(A, p, q, r)</code>
<code></code>
<code><span class="org-keyword">def</span> <span class="org-function-name">merge</span>(A, p, q, r):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">n</span> = q-r+1</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">L</span> = A[p:q]</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">R</span> = A[q:r]</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">l</span> = <span class="org-variable-name">r</span> = 0</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">if</span> L[l] &lt; R[r]:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> <span class="org-variable-name">A</span>[i] = L[l]</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> l++</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">else</span>:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> <span class="org-variable-name">A</span>[i] = R[r]</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> r++</code>
</pre>
</div>
</div>
</div>


<div id="outline-container-org7b4560b" class="outline-3">
<h3 id="org7b4560b"><span class="section-number-3">2.4</span> Heap sort</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Binary heap is a nearly complete binary tree, i.e. completely filled
on all levels except possibly the lowest, which is filled from left up
to a point. It can be either max-heap or min-heap, with the max and
min on top of heap respectively.
</p>

<p>
Some helper routines:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">parent</span>(i):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">return</span> floor(i/2)</code>
<code><span class="org-keyword">def</span> <span class="org-function-name">left</span>(i):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">return</span> 2*i</code>
<code><span class="org-keyword">def</span> <span class="org-function-name">right</span>(i):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">return</span> 2*i+1</code>
</pre>
</div>

<p>
Assuming the trees rooted at <code>left(i)</code> and <code>right(i)</code> are max-heaps,
but <code>A[i]</code> is not. Float down A[i] so that the tree rooted at <code>i</code> is
max-heap.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">max_heapify</span>(A, i):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">l</span> = left(i)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">r</span> = right(i)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-comment-delimiter"># </span><span class="org-fic">TODO</span><span class="org-comment"> check l,r &lt; A.heap_size</span></code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">value</span>, <span class="org-variable-name">index</span> = <span class="org-builtin">max</span>(A[i], A[l], A[r])</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">if</span> index != i:</code>
<code><span class="org-highlight-indentation"> </span>   swap(A[i], A[index])</code>
<code><span class="org-highlight-indentation"> </span>   max_heapify(A, index)</code>
</pre>
</div>

<p>
Build a heap from an array:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">build_max_heap</span>(A):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(A), 1, -1):</code>
<code><span class="org-highlight-indentation"> </span>   max_heapify(A, i)</code>
</pre>
</div>

<p>
Finally heap sort: in each loop, remove the top (current max item),
replace it with the last element in the heap, and do <code>heapify</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">heapsort</span>(A):</code>
<code><span class="org-highlight-indentation"> </span> build_max_heap(A)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(A), 2, -1):</code>
<code><span class="org-highlight-indentation"> </span>   swap(A[1], A[i])</code>
<code><span class="org-highlight-indentation"> </span>   A.heap_size--</code>
<code><span class="org-highlight-indentation"> </span>   max_heapify(A, 1)</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b2bbea" class="outline-3">
<h3 id="org1b2bbea"><span class="section-number-3">2.5</span> Quick sort</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The worst running time is \(\Theta(n^2)\), but it is often the best
practical choice for sorting, because it has average running time of
\(\Theta(n log n)\), with a small constant factor.
</p>

<p>
It is an divide-n-conquer algorithm. 
</p>
<ol class="org-ol">
<li>First find a pivot value \(x\), which is typically the last element
   in the array.</li>
<li>Then <b>partition the array into two parts, less than \(x\) and larger
   than \(x\)</b>.</li>
<li>recursively do this for the two partitions</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">sort</span>(A):</code>
<code><span class="org-highlight-indentation"> </span> quicksort(A, 1, <span class="org-builtin">len</span>(A))</code>
<code><span class="org-keyword">def</span> <span class="org-function-name">quicksort</span>(A, p, r):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">q</span> = partition(A, p, r)</code>
<code><span class="org-highlight-indentation"> </span> quicksort(A, p, q-1)</code>
<code><span class="org-highlight-indentation"> </span> quicksort(A, q+1, r)</code>
</pre>
</div>

<p>
The partition function:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">partition</span>(A, p, r):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">x</span> = A[r]</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">i</span> = p-1</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(p, r):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">if</span> A[j] &lt;= x:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> <span class="org-variable-name">i</span> = i+1</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> <span class="org-comment-delimiter"># </span><span class="org-comment">values less than x swapped to left part</span></code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> swap(A[i], A[j])</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-comment-delimiter"># </span><span class="org-comment">put the pivot value in place</span></code>
<code><span class="org-highlight-indentation"> </span> swap(A[i+1], A[r])</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">return</span> i+1</code>
</pre>
</div>

<p>
Or I prefer a functional way, in which case we don't even need to
specify the implementation of <code>partition</code> function, as it is obvious:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">quicksort</span>(A):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">x</span> = A[-1]</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">Al</span>, <span class="org-variable-name">Ar</span> = partition(A, x)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">return</span> [quicksort(Al), x, quicksort(Ar)]</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7907e4" class="outline-3">
<h3 id="orgd7907e4"><span class="section-number-3">2.6</span> Linear time sorting</h3>
<div class="outline-text-3" id="text-2-6">
<p>
All sorting algorithms above are comparison sorts, which can be proved
to take at least \(n log n\) running time. The algorithms in this
section makes certain assumptions to the array.
</p>
</div>

<div id="outline-container-org60a70bd" class="outline-4">
<h4 id="org60a70bd"><span class="section-number-4">2.6.1</span> couting sort</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Assume each of the elements are integers, in the range of [0,k].
</p>

<p>
The idea:
</p>
<ol class="org-ol">
<li>maintain an array C[0..k], where C[i] is the number of value <code>i</code> in A</li>
<li>change the array C such that C[i] is the number of values less than
   or equal to <code>i</code></li>
<li>put the elements directly to the place according to C</li>
</ol>
</div>
</div>

<div id="outline-container-org02bdc8b" class="outline-4">
<h4 id="org02bdc8b"><span class="section-number-4">2.6.2</span> <span class="todo TODO">TODO</span> Radix sort</h4>
</div>
<div id="outline-container-org1171497" class="outline-4">
<h4 id="org1171497"><span class="section-number-4">2.6.3</span> <span class="todo TODO">TODO</span> Bucket sort</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
Assume the input is drawn from a uniform distribution. The average
running time is linear.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org13a6f70" class="outline-2">
<h2 id="org13a6f70"><span class="section-number-2">3</span> Data structure</h2>
<div class="outline-text-2" id="text-3">
<p>
This section is mostly empty, because these are obvious. Most
important aspects of these data structures are the implementation of
their operations.
</p>
</div>

<div id="outline-container-org9be75a4" class="outline-3">
<h3 id="org9be75a4"><span class="section-number-3">3.1</span> linked list</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>linked list
<ul class="org-ul">
<li>head</li>
<li>tail</li>
<li>next</li>
</ul></li>
<li>doubly linked list
<ul class="org-ul">
<li>next</li>
<li>prev</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge528e79" class="outline-3">
<h3 id="orge528e79"><span class="section-number-3">3.2</span> stack &amp; queue</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>push</li>
<li>pop</li>
<li>enqueue</li>
<li>dequeue</li>
</ul>
</div>

<div id="outline-container-org038d5f3" class="outline-4">
<h4 id="org038d5f3"><span class="section-number-4">3.2.1</span> priority queue</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
It is implemented using a heap. Each item has a value. The <code>dequeue</code>
operation makes sure the popped item is the max one or min one, for
max-priority queue and min-priority queue, respectively.
</p>
</div>
</div>
</div>

<div id="outline-container-org5ff99d4" class="outline-3">
<h3 id="org5ff99d4"><span class="section-number-3">3.3</span> hash table</h3>
</div>
</div>

<div id="outline-container-org580f576" class="outline-2">
<h2 id="org580f576"><span class="section-number-2">4</span> Trees</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org94b4a37" class="outline-3">
<h3 id="org94b4a37"><span class="section-number-3">4.1</span> Search</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Using binary tree as example.  &amp; 
</p>

<p>
BFS:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-variable-name">q</span> = queue()</code>
<code><span class="org-keyword">def</span> <span class="org-function-name">traverse</span>(root):</code>
<code><span class="org-highlight-indentation"> </span> q.insert(root)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">while</span> (x = q.pop()):</code>
<code><span class="org-highlight-indentation"> </span>   q.insert(x.children)</code>
<code><span class="org-highlight-indentation"> </span>   visit(x)</code>
</pre>
</div>

<p>
DFS:
</p>

<div class="org-src-container">
<pre class="src src-python"><code>traverse(root)</code>
<code></code>
<code><span class="org-keyword">def</span> <span class="org-function-name">traverse</span>(node):</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.left)</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.right)</code>
</pre>
</div>
</div>
</div>



<div id="outline-container-orgdc41ce2" class="outline-3">
<h3 id="orgdc41ce2"><span class="section-number-3">4.2</span> Traversal</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Only defined for DFS.
</p>

<p>
Pre-order:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">traverse</span>(node):</code>
<code><span class="org-highlight-indentation"> </span> visit(node)</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.left)</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.right)</code>
</pre>
</div>

<p>
In-order (only defined for binary tree):
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">traverse</span>(node):</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.left)</code>
<code><span class="org-highlight-indentation"> </span> visit(node)</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.right)</code>
</pre>
</div>

<p>
Post-order:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">traverse</span>(node):</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.left)</code>
<code><span class="org-highlight-indentation"> </span> traverse(node.right)</code>
<code><span class="org-highlight-indentation"> </span> visit(node)</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6a98ed9" class="outline-3">
<h3 id="org6a98ed9"><span class="section-number-3">4.3</span> Special Trees</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org9fe3845" class="outline-4">
<h4 id="org9fe3845"><span class="section-number-4">4.3.1</span> Binary search tree</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
The value of a node is larger than all values in its left subtree, but
smaller than all values in the right subtree. As the name suggested,
it is mostly used for searching a value.
</p>
</div>
</div>

<div id="outline-container-org2382251" class="outline-4">
<h4 id="org2382251"><span class="section-number-4">4.3.2</span> red-black tree</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
A problem of search tree is that, the height may be very large, and
the running time is tight with the height.
</p>

<p>
The red-black tree is a binary search tree. It is designed to be a
balanced binary search tree, and guarantees that a simple path from
root to any leaf is no more than twice as long as any other, so that
the tree is approximately balanced.
</p>

<p>
Specifically, the property of a red-black tree:
</p>
<ol class="org-ol">
<li>every node is either red or black</li>
<li>the root is black</li>
<li>every leaf is black</li>
<li><b>if a node is red, both its children are black</b></li>
<li>for each node, all simple paths from the node to leaves contains
   the <b>same number of black nodes</b></li>
</ol>

<p>
Operations:
</p>
<ol class="org-ol">
<li>rotation</li>
<li>insertion</li>
<li>deletion</li>
</ol>
</div>
</div>

<div id="outline-container-org29cf993" class="outline-4">
<h4 id="org29cf993"><span class="section-number-4">4.3.3</span> interval tree</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
This is an example of augmenting data structures. It is an augmented
red-black tree. Each node of a tree contains two additional
attributes: the low and high of the sub-tree. Thus it is easier for
search, as we can use the interval to decide whether the subtree
contains the value at all.
</p>
</div>
</div>

<div id="outline-container-org49c8bec" class="outline-4">
<h4 id="org49c8bec"><span class="section-number-4">4.3.4</span> B-tree</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
B-tree is a balanced search tree, designed to work well on storage
devices. B-tree is not a binary tree.
</p>

<p>
Specifically, a B-tree is defined as:
</p>
<ol class="org-ol">
<li>each node contains n keys, where \(t \le n \le 2t-1\), and contains
   \(n+1\) children.</li>
<li>similar to binary search tree, the children of a node is divided by
   the keys, i.e. $ch<sub>1</sub> &le; key<sub>1</sub> &le; ch<sub>2</sub> &le; key<sub>2</sub> &#x2026;$.</li>
<li>All leaves have the same depth</li>
</ol>

<p>
The operations:
</p>
<ul class="org-ul">
<li>search: obvious</li>
<li>insertion: this is tricky. Since each tree node has a capacity of
  \([t,2t-1]\), when a node is full, it must be split, and a new key
  needs to be generated.</li>
<li>deletion: this is also tricky, as when the node is filled with less
  than \(t\), it must be merged.</li>
</ul>
</div>
</div>

<div id="outline-container-orge73d714" class="outline-4">
<h4 id="orge73d714"><span class="section-number-4">4.3.5</span> prefix-tree</h4>
<div class="outline-text-4" id="text-4-3-5">
<p>
The prefix tree, also called <i>Trie</i>, <i>digital tree</i>, <i>radix tree</i>, is
one kind of search tree, in which all descendants of a node share a
common prefix.
</p>
</div>
</div>
</div>

<div id="outline-container-org70e78b2" class="outline-3">
<h3 id="org70e78b2"><span class="section-number-3">4.4</span> Heap</h3>
<div class="outline-text-3" id="text-4-4">
</div>
<div id="outline-container-org30aa066" class="outline-4">
<h4 id="org30aa066"><span class="section-number-4">4.4.1</span> <span class="todo TODO">TODO</span> Fibonacci Heap</h4>
</div>
</div>
</div>

<div id="outline-container-org009bfc2" class="outline-2">
<h2 id="org009bfc2"><span class="section-number-2">5</span> Graph</h2>
<div class="outline-text-2" id="text-5">
<p>
The representation of a graph can be either a adjacent list or adjacent matrix.
</p>

<p>
A graph is (V,E), each edge has a weight.
</p>

<p>
Some general notations:
</p>
<ul class="org-ul">
<li>A <b>cut</b> of an undirected graph G is a partition of V, into \((S, V-S)\).</li>
<li>An edge E <b>crosses the cut</b> if its two ends belong to the different
  sides of the cut.</li>
<li>A cut <b>respects</b> a set of edges A if no edge in A crosses the cut</li>
<li>The minimum weight edge crossing the cut is called <b>light edge</b></li>
<li>More generally, we say an edge the <b>light edge</b> for some properties,
  if it is the minimum weight one among all edges satisfying the
  property.</li>
</ul>
</div>

<div id="outline-container-org3d0f218" class="outline-3">
<h3 id="org3d0f218"><span class="section-number-3">5.1</span> DFS &amp; BFS</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Same as trees, except checking for repeat (by coloring).
</p>
</div>
</div>

<div id="outline-container-org80f462b" class="outline-3">
<h3 id="org80f462b"><span class="section-number-3">5.2</span> topological sort</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Run DFS (or BFS) and print out the nodes.
</p>
</div>
</div>

<div id="outline-container-orgcdc6d9f" class="outline-3">
<h3 id="orgcdc6d9f"><span class="section-number-3">5.3</span> Minimum Spanning Tree</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Given a graph (V,E), and each edge has a weight. Find the subset of
edges \(E' \subset E\) such that (V,E') is a tree. This tree is called
<i>spanning tree</i>. The spanning tree with minimum sum of edge weights is
called the minimum spanning tree.
</p>

<p>
General idea: We grow a set of edges A, from \(\emptyset\), and maintain
the invariant that is a subset of some minimum spanning tree. If we
can add an edge to A, and don't violate this invariant, we call it
<b>safe edge</b> to A.
</p>

<pre class="example">
<code>A = {}</code>
<code>while A is not a spanning tree:</code>
<code>  find (u,v) that is safe for A</code>
<code>  A = A union {(u,v)}</code>
</pre>

<p>
Theorem 23.1:
</p>

<blockquote>
<p>
\(A\) is a subset of \(E\), and \(A\) is in some minimum spanning tree of
G. Cut \(c\) respects A. Then the light edge of \(c\) is safe to \(A\).
</p>
</blockquote>

<p>
Corollary 23.2
</p>

<blockquote>
<p>
A is a subset of E and A is included in some minimum spanning tree of
G. We have a forest F=(V,A). In the forest, there will be many
connected components \(C_i\).
</p>

<p>
Then the light edge connecting \(C_i\) to \(C_j\) is safe to A.
</p>
</blockquote>
</div>

<div id="outline-container-org64c794b" class="outline-4">
<h4 id="org64c794b"><span class="section-number-4">5.3.1</span> Kruskal's algorithm</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
This algorithm <b>grow the edges, or forest</b>. It sorts all edges.
Starting from empty, greedily find the smallest edge as long as it
does not form a cycle.
</p>

<pre class="example">
<code>edges = sorted(edges, key=weight)</code>
<code>A = {}</code>
<code>for (u,v) in edges:</code>
<code>  if u,v are not in the same component of A:</code>
<code>    add (u,v) to A</code>
</pre>
</div>
</div>

<div id="outline-container-orgebc825f" class="outline-4">
<h4 id="orgebc825f"><span class="section-number-4">5.3.2</span> Prim's algorithm</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
This algorithm will <b>grow the tree</b>, i.e. at any given time, the
result is a tree. Start from an arbitrary node, add it to A. Each
step, add to A the light edge from a node A to the rest of G.
</p>

<pre class="example">
<code>for u in G.V:</code>
<code>  u.key = infinite</code>
<code>  u.parent = None</code>
<code>r = random_node()</code>
<code>Q = G.V</code>
<code>while Q:</code>
<code>  u = extract_min(Q, key=key)</code>
<code>  for v in G.Adj[u]:</code>
<code>    if v in Q and w(u,v) &lt; v.key:</code>
<code>      v.key = w(u,v)</code>
<code>      v.parent = u</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-org766343f" class="outline-3">
<h3 id="org766343f"><span class="section-number-3">5.4</span> Shortest path</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Given a weighted, directed graph, the shortest path from u to v is the
path that has minimum weight. We talk mainly about single-source,
single-destination shortest path.
</p>

<p>
We add to attributes to vertices of the graph:
</p>
<ul class="org-ul">
<li><code>v.d</code>: the upper bound of shortest path from s to v. Initialize to infinite.</li>
<li><code>v.pred</code>: the predecessor for that upper bound. Initialize to nil.</li>
</ul>

<p>
First a helper function, relax of an edge (u,v), by checking whether
setting v.pred to u improve v.d:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">relax</span>(u,v):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">if</span> v.d &gt; u.d + w(u,v):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">v.d</span> = u.d + w(u,v)</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">v.pred</span> = u</code>
</pre>
</div>
</div>


<div id="outline-container-orgd60e0ac" class="outline-4">
<h4 id="orgd60e0ac"><span class="section-number-4">5.4.1</span> Bellman-Ford algorithm</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
This is kind of a brute force algorithm. It relax all edges \(|V|-1\)
times. Each time, at least one node is set to its optimal, and the
source vertex s.d=0, thus \(|V|-1\) iterations will make sure all
vertices are set to optimal.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">bellman_ford</span>():</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(|V|-1):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">for</span> (u,v) <span class="org-keyword">in</span> |E|:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> relax(u,v)</code>
</pre>
</div>

<p>
The running time is |V||E|
</p>
</div>
</div>

<div id="outline-container-org6f7e7c6" class="outline-4">
<h4 id="org6f7e7c6"><span class="section-number-4">5.4.2</span> Dijkstra's algorithm</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
In addition to weighted, directly graph, it assumes all weights are
non-negative. The key idea has two fold:
</p>
<ol class="org-ol">
<li>It maintains a set S of vertices whose "d" has been determined.</li>
<li>Every iteration, it tries to determine one more vertex. It greedily
   choose the one with minimum "d".</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">dijkstra</span>():</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">sovled</span> = {}</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">s.d</span> = 0</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">q</span> = min_priority_queue(V, <span class="org-string">"d"</span>)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">while</span> q:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">u</span> = q.pop_min()</code>
<code><span class="org-highlight-indentation"> </span>   solved.insert(u)</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">for</span> v <span class="org-keyword">in</span> u.adj:</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> relax(u,v)</code>
</pre>
</div>


<p>
The running time is \(|V|^2 + |E|\). If the priority queue is
implemented using Fibonacci heap (TODO), the running time is \(|V|
log |V| + |E|\).
</p>
</div>
</div>
</div>


<div id="outline-container-orga1754da" class="outline-3">
<h3 id="orga1754da"><span class="section-number-3">5.5</span> Network Flow Problems</h3>
<div class="outline-text-3" id="text-5-5">
<p>
The constraints of a flow network:
</p>

<ol class="org-ol">
<li>capacity constraint: 0 &le; f(u,v) &le; c(u,v)</li>
<li>flow conservation: &sum;<sub>v&isin; V</sub> f(v,u) = &sum;<sub>v &isin; V</sub>
   f(u,v). I.e. the ingoing and outgoing flow of a node shall equal.</li>
</ol>

<p>
We are interested in two equivalent problems:
</p>
<ul class="org-ul">
<li>maximum flow</li>
<li>minimum cut</li>
</ul>

<p>
Residual network:
</p>
<ul class="org-ul">
<li>Residual network: given capacity c and flow f, the capacity of
  residual network \(c_f\) is simply \(c(u,v)-f(u,v)\).</li>
<li>augmenting path: given a flow network G and a flow f, the augmenting
  path p is a simple path from s to t in the residual network \(G_f\)</li>
</ul>

<p>
The cut of a flow is (S,T) where S + T = V. The flow f(S,T) across the
cut is defined as:
</p>

<p>
\[f(S,T) = \sum_{u\in S} \sum_{v \in T} f(u,v) - \sum_{u\in S} \sum_{v \in T} f(v,u)\]
</p>

<p>
The capacity of the cut is:
</p>

<p>
\[c(S,T) = \sum_{u\in S} \sum_{v \in T} c(u,v)\].
</p>

<p>
The minimum cut is the one whose capacity is minimum. The max-flow
min-cut theorem states that the minimum cut equals to the
max-flow. Specifically, the following conditions are equivalent:
</p>

<ol class="org-ol">
<li>f is maximum flow in G</li>
<li>The residual network \(G_f\) contains no augmenting paths</li>
<li>|f|=c(S,T) for some cut (S,T) of G.
<ul class="org-ul">
<li>This should be further written as |f| equal to the capacity of
     minimum cut of G.</li>
</ul></li>
</ol>
</div>

<div id="outline-container-org9280772" class="outline-4">
<h4 id="org9280772"><span class="section-number-4">5.5.1</span> Ford-Fulkerson method</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
It is a method instead of an algorithm because it has several
different implementations with different running time.
</p>

<p>
The general ford-fulkerson:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-variable-name">f</span> = 0</code>
<code><span class="org-keyword">while</span> <span class="org-constant">True</span>:</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">res_net</span> = residual_network(G, f):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">aug_p</span> = augmenting_path(res_net)</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">if</span> <span class="org-keyword">not</span> aug_p: <span class="org-keyword">break</span></code>
<code><span class="org-highlight-indentation"> </span> do_augment(aug_p)</code>
<code><span class="org-keyword">return</span> f</code>
</pre>
</div>

<p>
Apparently the key point is how to find the augmenting path. If chosen
poorly, it may not terminate.
</p>
</div>
</div>

<div id="outline-container-orgdb5b754" class="outline-4">
<h4 id="orgdb5b754"><span class="section-number-4">5.5.2</span> Edmonds-Karp algorithm</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
This algorithm is to use BFS for finding the augmenting path. The
shortest path (with unit edge weight) from s to t is selected in this
way. It runs in O(VE<sup>2</sup>), i.e. polynomial time.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org7c76cff" class="outline-2">
<h2 id="org7c76cff"><span class="section-number-2">6</span> <span class="todo TODO">TODO</span> String algorithms</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgb0108ee" class="outline-3">
<h3 id="orgb0108ee"><span class="section-number-3">6.1</span> <span class="todo TODO">TODO</span> Substring matching</h3>
</div>
<div id="outline-container-orga3d62da" class="outline-3">
<h3 id="orga3d62da"><span class="section-number-3">6.2</span> <span class="todo TODO">TODO</span> Rabin-Karp algorithm</h3>
</div>
<div id="outline-container-org4b74537" class="outline-3">
<h3 id="org4b74537"><span class="section-number-3">6.3</span> <span class="todo TODO">TODO</span> Knuth-Morris-Pratt algorithm</h3>
</div>
</div>

<div id="outline-container-org1f6c8f4" class="outline-2">
<h2 id="org1f6c8f4"><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> Dynamic Programming</h2>
<div class="outline-text-2" id="text-7">
<p>
The core idea is to store the solution to subproblems, thus avoid
repeated computation. It uses additional memory to save computation
time.
</p>

<p>
There are often two approaches for dynamic programming:
</p>
<ol class="org-ol">
<li>Do recursion as usual, but just keep a look up table for each
   subproblem, i.e. when solving a subproblem, check the table to see
   if it is already solved, if not, solve it and store its result.</li>
<li>This is the most commonly used and most efficient algorithm. The
   above is inefficient by a constant factor. We can order the
   subproblems based on its size, and the latter subproblems often
   directly uses the results from the smaller subproblems.</li>
</ol>
</div>


<div id="outline-container-org37d1df9" class="outline-3">
<h3 id="org37d1df9"><span class="section-number-3">7.1</span> The rod-cutting problem</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Given a rod of length n, and a price table mapping from lengths to
prices. Determine the maximum revenue obtainable by cutting and
selling the rod.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span class="org-keyword">def</span> <span class="org-function-name">cutrod</span>(price_table, n):</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-variable-name">r</span>[0] = 0</code>
<code><span class="org-highlight-indentation"> </span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, n):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">q</span>=0</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, i):</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-highlight-indentation"> </span> <span class="org-variable-name">q</span> = <span class="org-builtin">max</span>(q, p[i]+r[i-j])</code>
<code><span class="org-highlight-indentation"> </span>   <span class="org-variable-name">r</span>[i] = q</code>
<code><span class="org-keyword">return</span> r[n]</code>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf259a87" class="outline-3">
<h3 id="orgf259a87"><span class="section-number-3">7.2</span> <span class="todo TODO">TODO</span> Largest common subsequence</h3>
</div>
</div>

<div id="outline-container-orgf3ad410" class="outline-2">
<h2 id="orgf3ad410"><span class="section-number-2">8</span> Other Named Algorithm</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org469d3df" class="outline-3">
<h3 id="org469d3df"><span class="section-number-3">8.1</span> Bloom Filter</h3>
<div class="outline-text-3" id="text-8-1">
<p>
It is used to judge whether an item is in a set or not.
</p>

<p>
If bloom() return false, it is false. But if bloom() return true,
it may not be true.
</p>

<p>
The basic idea is, hash(item), map it in a vector of m size.
The vector is 0 initially.
v[hash(item)] is set to 1.
To reduce fault rate, use k hash functions.
</p>

<p>
To verify, only if all k hash functions has 1 in the vector will it return true.
Otherwise return false.
</p>
</div>
</div>
</div>


<div id="outline-container-org552d1ff" class="outline-2">
<h2 id="org552d1ff"><span class="section-number-2">9</span> <span class="todo TODO">TODO</span> NP-Completeness</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orgb5676d0" class="outline-3">
<h3 id="orgb5676d0"><span class="section-number-3">9.1</span> Approximation algorithms</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-org2699a76" class="outline-4">
<h4 id="org2699a76"><span class="section-number-4">9.1.1</span> the vertex-cover problem</h4>
</div>
<div id="outline-container-org283aa51" class="outline-4">
<h4 id="org283aa51"><span class="section-number-4">9.1.2</span> the traveling-salesman problem</h4>
</div>
<div id="outline-container-orga5cb8e9" class="outline-4">
<h4 id="orga5cb8e9"><span class="section-number-4">9.1.3</span> the set-covering problem</h4>
</div>
<div id="outline-container-orge26eecb" class="outline-4">
<h4 id="orge26eecb"><span class="section-number-4">9.1.4</span> the subset-sum problem</h4>
</div>
</div>
</div>

<div id="outline-container-org6fec13e" class="outline-2">
<h2 id="org6fec13e"><span class="section-number-2">10</span> <span class="todo TODO">TODO</span> Linear Programming (LP)</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-orgca2098b" class="outline-3">
<h3 id="orgca2098b"><span class="section-number-3">10.1</span> Standard and slack forms</h3>
</div>
<div id="outline-container-org6593bb1" class="outline-3">
<h3 id="org6593bb1"><span class="section-number-3">10.2</span> Formulating</h3>
</div>
<div id="outline-container-orgacebaea" class="outline-3">
<h3 id="orgacebaea"><span class="section-number-3">10.3</span> Simplex algorithm</h3>
</div>
<div id="outline-container-orga37e185" class="outline-3">
<h3 id="orga37e185"><span class="section-number-3">10.4</span> Duality</h3>
</div>
</div>

<div id="outline-container-org976450e" class="outline-2">
<h2 id="org976450e"><span class="section-number-2">11</span> Tips</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org7ce18e6" class="outline-3">
<h3 id="org7ce18e6"><span class="section-number-3">11.1</span> <span class="todo TODO">TODO</span> Devide-and-Conquer</h3>
</div>
<div id="outline-container-orga5f2524" class="outline-3">
<h3 id="orga5f2524"><span class="section-number-3">11.2</span> Recursive</h3>
</div>
<div id="outline-container-org2377596" class="outline-3">
<h3 id="org2377596"><span class="section-number-3">11.3</span> Dynamic Programming</h3>
</div>
</div>

<div id="outline-container-org1eaa3d2" class="outline-2">
<h2 id="org1eaa3d2"><span class="section-number-2">12</span> Old Writings</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org1a43fa9" class="outline-3">
<h3 id="org1a43fa9"><span class="section-number-3">12.1</span> Barrel shifter</h3>
<div class="outline-text-3" id="text-12-1">
<p>
A barrel shifter is a digital circuit that can shift a data word
by a specified number of bits in one clock cycle.
</p>


<div class="figure">
<p><img src="https://farm8.staticflickr.com/7578/16260221182_53a096f18c_o.png" alt="16260221182_53a096f18c_o.png" />
</p>
</div>

<p>
In the above image, x is input and y is output.
</p>

<p>
For shift 1, all the erjiguan on the green line exist, while others
not.
</p>
</div>

<div id="outline-container-org4e6bd0f" class="outline-4">
<h4 id="org4e6bd0f"><span class="section-number-4">12.1.1</span> shift register</h4>
<div class="outline-text-4" id="text-12-1-1">

<div class="figure">
<p><img src="https://farm9.staticflickr.com/8671/16074934899_03921f148b_o.png" alt="16074934899_03921f148b_o.png" />
</p>
</div>

<p>
F0、F1、F2、F3是四个边沿触发的D触发器，每个触发器的输出端Q接到右边一个
触发器的输入端D。因为从时钟信号CP的上升沿加到触发器上开始到输出端新状
态稳定地建立起来有一段延迟时间，所以当时钟信号同时加到四个触发器上时，
每个触发器接收的都是左边一个触发器中原来的数据(F0接收的输入数据D1)。寄
存器中的数据依次右移一位。
</p>
</div>
</div>
</div>

<div id="outline-container-orge29b732" class="outline-3">
<h3 id="orge29b732"><span class="section-number-3">12.2</span> Linear congruential generator</h3>
<div class="outline-text-3" id="text-12-2">
<p>
A linear congruential generator (LCG)
is an algorithm that yields a sequence of pseudo-randomized numbers.
</p>

<p>
pseudorandom number generator algorithms(PRNG).
</p>

<p>
\(X_{n+1} = (aX_n+c) mod m\)
</p>

<p>
X array is the pseudorandom.
</p>

<ul class="org-ul">
<li>\(X_0\): seed</li>
<li><code>m</code>: modulus</li>
<li><code>a</code>: multiplier</li>
<li><code>c</code>: increment</li>
</ul>

<p>
If c = 0,
the generator is often called a multiplicative congruential generator (MCG),
or Lehmer RNG.
If c ≠ 0, the method is called a mixed congruential generator.
</p>
</div>
</div>


<div id="outline-container-org461937a" class="outline-3">
<h3 id="org461937a"><span class="section-number-3">12.3</span> Dynamic Programming</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Solve problem by breaking down into simpler sub-problems.
</p>
</div>

<div id="outline-container-org42cfcfc" class="outline-4">
<h4 id="org42cfcfc"><span class="section-number-4">12.3.1</span> One dimension</h4>
<div class="outline-text-4" id="text-12-3-1">
<p>
Given n, find the number of different ways to write n as the sum of 1,3,4
</p>
</div>

<div id="outline-container-orgae06871" class="outline-5">
<h5 id="orgae06871"><span class="section-number-5">12.3.1.1</span> Define sub-problems</h5>
<div class="outline-text-5" id="text-12-3-1-1">
<p>
D<sub>n</sub> is the number of ways to write n as sum of 1,3,4
</p>
</div>
</div>

<div id="outline-container-org209641c" class="outline-5">
<h5 id="org209641c"><span class="section-number-5">12.3.1.2</span> Recurrence formula</h5>
<div class="outline-text-5" id="text-12-3-1-2">
<p>
D<sub>n</sub> = D<sub>n-1</sub> + D<sub>n-3</sub> + D<sub>n-4</sub>
</p>
</div>
</div>
</div>

<div id="outline-container-org355aa34" class="outline-4">
<h4 id="org355aa34"><span class="section-number-4">12.3.2</span> Two Dimensions</h4>
<div class="outline-text-4" id="text-12-3-2">
<p>
Given two string x and y, find the length of longest common sub-sequence.
</p>
</div>

<div id="outline-container-orgc34b2b0" class="outline-5">
<h5 id="orgc34b2b0"><span class="section-number-5">12.3.2.1</span> Define sub-problems</h5>
<div class="outline-text-5" id="text-12-3-2-1">
<p>
D<sub>ij</sub> is the length for x<sub>i..i</sub> and y<sub>1..j</sub>
</p>
</div>
</div>

<div id="outline-container-org4c35e09" class="outline-5">
<h5 id="org4c35e09"><span class="section-number-5">12.3.2.2</span> Recurrence formula</h5>
<div class="outline-text-5" id="text-12-3-2-2">
<p>
D<sub>ij</sub> =
</p>
<ul class="org-ul">
<li>if x<sub>i</sub> = y<sub>i</sub>: D<sub>i-1,j-1</sub> + 1</li>
<li>otherwise: max{D<sub>i-1,j</sub>, D<sub>i,j-1</sub>}</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org042660c" class="outline-4">
<h4 id="org042660c"><span class="section-number-4">12.3.3</span> Interval DP</h4>
<div class="outline-text-4" id="text-12-3-3">
<p>
Given a string x=x<sub>1..n</sub>,
find the minimum number of characters that need to be inserted to make it a palindrome.
</p>
</div>

<div id="outline-container-orgee99c88" class="outline-5">
<h5 id="orgee99c88"><span class="section-number-5">12.3.3.1</span> Define sub-problem</h5>
<div class="outline-text-5" id="text-12-3-3-1">
<p>
D<sub>i,j</sub> be the minimum number of characters.
</p>
</div>
</div>

<div id="outline-container-org0146c3b" class="outline-5">
<h5 id="org0146c3b"><span class="section-number-5">12.3.3.2</span> Recurrence formula</h5>
<div class="outline-text-5" id="text-12-3-3-2">
<p>
say y<sub>1..k</sub> is the palindrome for x<sub>i..j</sub>,
<b>we have either y<sub>1</sub> = x<sub>i</sub> or y<sub>k</sub> = x<sub>j</sub></b>
</p>

<p>
D<sub>ij</sub> =
</p>
<ul class="org-ul">
<li>if x<sub>i</sub> &ne; x<sub>j</sub>: 1 + min{D<sub>i+1,j</sub>, D<sub>i,j-1</sub>}</li>
<li>if x<sub>i</sub> = x<sub>j</sub>: D<sub>i+1,j-1</sub></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8401f07" class="outline-4">
<h4 id="org8401f07"><span class="section-number-4">12.3.4</span> Tree DP</h4>
<div class="outline-text-4" id="text-12-3-4">
<p>
Given a tree, color nodes black as many as possible without coloring two adjacent nodes.
</p>
</div>

<div id="outline-container-org031b87f" class="outline-5">
<h5 id="org031b87f"><span class="section-number-5">12.3.4.1</span> Define</h5>
<div class="outline-text-5" id="text-12-3-4-1">
<ul class="org-ul">
<li>B(r) as the maximum nodes if the (root) node r is colored black.</li>
<li>W(r) as the maximum nodes if the (root) node r is colored white.</li>
</ul>
</div>
</div>

<div id="outline-container-org9f2ec08" class="outline-5">
<h5 id="org9f2ec08"><span class="section-number-5">12.3.4.2</span> Recurrence</h5>
<div class="outline-text-5" id="text-12-3-4-2">
<ul class="org-ul">
<li>B(v) = 1 + &sum;<sub>children</sub> W(c)</li>
<li>W(v) = 1 + &sum;<sub>children</sub> max{B(c), W(c)}</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org508f6d0" class="outline-3">
<h3 id="org508f6d0"><span class="section-number-3">12.4</span> String Algorithm</h3>
<div class="outline-text-3" id="text-12-4">
</div>
<div id="outline-container-org4a25499" class="outline-4">
<h4 id="org4a25499"><span class="section-number-4">12.4.1</span> Knuth–Morris–Pratt(KMP)</h4>
<div class="outline-text-4" id="text-12-4-1">
<blockquote>
<p>
Match a pattern string P inside given long string T.
</p>
</blockquote>

<p>
The idea is, when failure happens, we shift multiple position instead of just 1.
We are able to do that because when the failure happens, we know what have been examined, so we have everything available to make the best choice.
Specifically, we build a look-up table, <b>for the pattern string</b>.
The table has an entry for each index of the string, describing the shift position.
E.g., <code>ABCABDA</code>, the lookup table will be: <code>0000120</code>.
Actually the table refers to what's the substring matched the prefix of the pattern string.
</p>

<p>
The algorithm to build the table:
</p>

<div class="org-src-container">
<pre class="src src-lisp-interaction"><code>  (<span class="org-keyword">defun</span> <span class="org-function-name">build-table</span> (pattern)</code>
<code>    (<span class="org-keyword">cl-loop</span> with pos = 2</code>
<code>             with match = 0</code>
<code>             with size = (length pattern)</code>
<code>             with ret = (make-vector size 0)</code>
<code>             initially do</code>
<code>             <span class="org-comment-delimiter">;; </span><span class="org-comment">here I assume size is at least 2</span></code>
<code>             (<span class="org-keyword">assert</span> (&gt; size 1))</code>
<code>             (aset ret 0 -1)</code>
<code>             (aset ret 1 0)</code>
<code>             while (&lt; pos size) do</code>
<code>             (<span class="org-keyword">if</span> (equal (elt pattern (- pos 1)) (elt pattern match))</code>
<code>                 (<span class="org-keyword">progn</span></code>
<code>                   (aset ret pos (+ 1 match))</code>
<code>                   (<span class="org-keyword">incf</span> match)</code>
<code>                   (<span class="org-keyword">incf</span> pos))</code>
<code>               (<span class="org-keyword">if</span> (&gt; match 0)</code>
<code>                   (<span class="org-keyword">setq</span> match (elt ret match))</code>
<code>                 (aset ret pos 0)</code>
<code>                 (<span class="org-keyword">incf</span> pos)))</code>
<code>             finally return ret))</code>
<code></code>
<code>  (<span class="org-keyword">ert-deftest</span> <span class="org-function-name">build-table-test</span>()</code>
<code>    (should (equal (build-table <span class="org-string">"AABAAAC"</span>) [-1 0 1 0 1 2 2]))</code>
<code>    (should (equal (build-table <span class="org-string">"ABCABCD"</span>) [-1 0 0 0 1 2 3])))</code>
<code></code>
<code>  (ert-run-test (ert-get-test 'build-table-test))</code>
</pre>
</div>
</div>

<div id="outline-container-org3dbbc13" class="outline-5">
<h5 id="org3dbbc13"><span class="section-number-5">12.4.1.1</span> 214. Shortest Palindrome</h5>
<div class="outline-text-5" id="text-12-4-1-1">
<blockquote>
<p>
Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.
</p>
</blockquote>
</div>

<ol class="org-ol">
<li><a id="org677d451"></a>KMP<br />
<div class="outline-text-6" id="text-12-4-1-1-1">
<p>
It is easy to convert the problem to find the longest Palindrome at the beginning of s.
To apply KMP, we write the string as <code>s + '#' + reverse(s)</code>.
Then we build the KMP table for this string.
What we need is to find the largest number inside KMP table.
</p>
</div>
</li>

<li><a id="org3026fe6"></a>brute force<br />
<div class="outline-text-6" id="text-12-4-1-1-2">
<p>
I have a brute-force that "just" pass the tests.
</p>

<div class="org-src-container">
<pre class="src src-C++"><code><span class="org-keyword">class</span> <span class="org-type">Solution</span> {</code>
<code><span class="org-keyword">public</span>:</code>
<code>  <span class="org-type">string</span> <span class="org-function-name">shortestPalindrome</span>(<span class="org-type">string</span> <span class="org-variable-name">s</span>) {</code>
<code>    <span class="org-keyword">if</span> (s.size() == 0) <span class="org-keyword">return</span> s;</code>
<code>    <span class="org-keyword">if</span> (s.size() == 1) <span class="org-keyword">return</span> s;</code>
<code>    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span>=(s.size()-1)/2;i&gt;0;i--) {</code>
<code>      <span class="org-keyword">if</span> (check(s, i, <span class="org-constant">false</span>)) {</code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; "success on " &lt;&lt; i &lt;&lt; " false"  &lt;&lt; "\n";</span></code>
<code>        <span class="org-type">string</span> <span class="org-variable-name">sub</span> = s.substr(<span class="org-type">i</span>*2+2);</code>
<code>        <span class="org-constant">std</span>::reverse(sub.begin(), sub.end());</code>
<code>        <span class="org-keyword">return</span> sub + s;</code>
<code>      } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (check(s, <span class="org-type">i</span>, <span class="org-constant">true</span>)) {</code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; "success on " &lt;&lt; i &lt;&lt; " true"  &lt;&lt; "\n";</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">THREE</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">1 2 3 4 5 6</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">- - -|- - -</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">6/2=3</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">1 2 3 4 5</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">- - | - -</span></code>
<code>        <span class="org-comment-delimiter">// </span><span class="org-comment">i*2+1 - end</span></code>
<code>        <span class="org-type">string</span> <span class="org-variable-name">sub</span> = s.substr(<span class="org-type">i</span>*2+1);</code>
<code>        <span class="org-constant">std</span>::reverse(sub.begin(), sub.end());</code>
<code>        <span class="org-keyword">return</span> sub + s;</code>
<code>      }</code>
<code>    }</code>
<code>    <span class="org-type">string</span> <span class="org-variable-name">sub</span>;</code>
<code>    <span class="org-keyword">if</span> (check(s, 0, <span class="org-constant">false</span>)) {</code>
<code>      sub = s.substr(2);</code>
<code>    } <span class="org-keyword">else</span> {</code>
<code>      sub = s.substr(1);</code>
<code>    }</code>
<code>    <span class="org-constant">std</span>::reverse(sub.begin(), sub.end());</code>
<code>    <span class="org-keyword">return</span> sub + s;</code>
<code>  }</code>
<code>  <span class="org-comment-delimiter">/**</span></code>
<code><span class="org-comment">   * on: pivot on idx or not</span></code>
<code><span class="org-comment">   */</span></code>
<code>  <span class="org-type">bool</span> <span class="org-function-name">check</span>(<span class="org-type">string</span> &amp;<span class="org-variable-name">s</span>, <span class="org-type">int</span> <span class="org-variable-name">idx</span>, <span class="org-type">bool</span> <span class="org-variable-name">on</span>) {</code>
<code>    <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; idx  &lt;&lt; "\n";</span></code>
<code>    <span class="org-keyword">if</span> (idx &lt;0 || idx &gt;= (<span class="org-type">int</span>)s.size()) <span class="org-keyword">return</span> <span class="org-constant">false</span>;</code>
<code>    <span class="org-type">int</span> <span class="org-variable-name">i</span>=0,<span class="org-variable-name">j</span>=0;</code>
<code>    <span class="org-keyword">if</span> (on) {</code>
<code>      i=idx-1;</code>
<code>      j=idx+1;</code>
<code>    } <span class="org-keyword">else</span> {</code>
<code>      i = idx;</code>
<code>      j = idx+1;</code>
<code>    }</code>
<code>    <span class="org-type">int</span> <span class="org-variable-name">size</span> = s.size();</code>
<code>    <span class="org-keyword">while</span> (i &gt;= 0) {</code>
<code>      <span class="org-keyword">if</span> (j &gt;= size) <span class="org-keyword">return</span> <span class="org-constant">false</span>;</code>
<code>      <span class="org-keyword">if</span> (s[i] != s[j]) <span class="org-keyword">return</span> <span class="org-constant">false</span>;</code>
<code>      i--;</code>
<code>      j++;</code>
<code>    }</code>
<code>    <span class="org-keyword">return</span> <span class="org-constant">true</span>;</code>
<code>  }</code>
<code>};</code>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org57a92eb" class="outline-4">
<h4 id="org57a92eb"><span class="section-number-4">12.4.2</span> Boyer Moore</h4>
<div class="outline-text-4" id="text-12-4-2">
<p>
It is a string match algorithm.
</p>

<p>
The rule lookup is in a hash table,
which can be formed during proprocessing of pattern.
</p>

<p>
In the following examples, the lower case denote the matched or unmatched part for illustration purpose only.
They are upper case when considering matching.
</p>
</div>
<div id="outline-container-orgd22a9d7" class="outline-5">
<h5 id="orgd22a9d7"><span class="section-number-5">12.4.2.1</span> Bad Character Rule</h5>
<div class="outline-text-5" id="text-12-4-2-1">
<p>
Match from last. In the below example, the suffix <code>MAN</code> matches, but <code>N</code> does not match. Shift the pattern so that the first N (counted from last) go to the <code>N</code> place.
</p>

<div class="org-src-container">
<pre class="src src-text"><code>- - - - X - - K - - -</code>
<code>A N P A n M A N A M -</code>
<code>- N n A A M A N - - -</code>
<code>- - - N n A A M A N -</code>
</pre>
</div>

<p>
from right end to left.
when a mismatch happens at `n`,
find to left a `n`, then shift it to the position.
</p>
</div>
</div>

<div id="outline-container-orgaa46848" class="outline-5">
<h5 id="orgaa46848"><span class="section-number-5">12.4.2.2</span> Good Suffix Rule</h5>
<div class="outline-text-5" id="text-12-4-2-2">
<p>
Similar to the bad rule, find the matched, in this case <code>NAM</code>.
Then, if an failure happens, move the same part to the left of that match (in this case another <code>NAM</code> at the left) to that position.
</p>
<div class="org-src-container">
<pre class="src src-text"><code>- - - - X - - K - - - - -</code>
<code>M A N P A n a m A N A P -</code>
<code>A n a m P n a m - - - - -</code>
<code>- - - - A n a m P N A M -</code>
</pre>
</div>

<p>
when a mismatch happens,
<code>nam</code> is the longest good suffix.
Find <code>nam</code> to the left,
and shift it to the position.
</p>
</div>
</div>

<div id="outline-container-org38c44ec" class="outline-5">
<h5 id="org38c44ec"><span class="section-number-5">12.4.2.3</span> Galil Rule</h5>
<div class="outline-text-5" id="text-12-4-2-3">
<p>
As opposed to shifting, the Galil rule deals with speeding up the actual comparisons done at each alignment by skipping sections that are known to match.
Suppose that at an alignment k1,
P is compared with T down to character c of T.
Then if P is shifted to k2 such that its left end is between c and k1,
in the next comparison phase a prefix of P must match the substring T[(k2 - n)..k1].
Thus if the comparisons get down to position k1 of T,
an occurrence of P can be recorded without explicitly comparing past k1.
In addition to increasing the efficiency of Boyer-Moore,
the Galil rule is required for proving linear-time execution in the worst case.
</p>
</div>
</div>
</div>

<div id="outline-container-org908c075" class="outline-4">
<h4 id="org908c075"><span class="section-number-4">12.4.3</span> Rabin-Karp Algorithm</h4>
<div class="outline-text-4" id="text-12-4-3">
<p>
It is a string searching algorithm.
</p>

<p>
The Naive Solution for string search:
</p>

<div class="org-src-container">
<pre class="src src-C"><code><span class="org-type">int</span> <span class="org-function-name">func</span>(<span class="org-type">char</span> <span class="org-variable-name">s</span>[], <span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">char</span> <span class="org-variable-name">pattern</span>[], <span class="org-type">int</span> <span class="org-variable-name">m</span>) {</code>
<code>  <span class="org-type">char</span> *<span class="org-variable-name">ps</span>,*<span class="org-variable-name">pp</span>; <span class="org-comment-delimiter">//</span><span class="org-comment">*</span></code>
<code>  ps=s;</code>
<code>  pp=pattern;</code>
<code>  <span class="org-keyword">for</span> (i=0;i&lt;n-m+1;) {</code>
<code>    <span class="org-keyword">if</span> (*pp==<span class="org-string">'\0'</span>) <span class="org-keyword">return</span> i; <span class="org-comment-delimiter">//</span><span class="org-comment">*</span></code>
<code>    <span class="org-keyword">if</span> (*ps == *pp) { <span class="org-comment-delimiter">//</span><span class="org-comment">*</span></code>
<code>      ps++;pp++;</code>
<code>    } <span class="org-keyword">else</span> {</code>
<code>      i++;</code>
<code>      ps=s+i;</code>
<code>      pp=pattern;</code>
<code>    }</code>
<code>  }</code>
<code>}</code>
</pre>
</div>

<p>
The running time is \(O(mn)\).
</p>

<p>
The Rabin-Karp algorithm use hash for pattern match.
First calculate <code>hash(pattern)</code>.
Then for every s[i,i+m-1], calculate the hash.
Then compare them.
</p>

<p>
The key of the algorithm is the hash function.
If the hash function need time m to compute, then it is still \(O(mn)\).
If the collision happens often, then even if hash matches, we still need to verify.
</p>

<p>
Key point is to select a hast function, such that <code>hash(i,i+m-1)</code> can be computed
by <code>hash(i-1,i+m-2)</code>.
</p>

<p>
If add all characters' ASCII together, collision is often.
</p>

<p>
The used hash function is:
select a large prime as base, 101 for example.
Hash value is:
</p>

\begin{equation}
hash("abc") = ASCII('a')*101^2 + ASCII('b')*101^1 + ASCII('c')*101^0
\end{equation}

<p>
Rabin-Karp is not so good for single string match because the worst case is \(O(mn)\),
but it is the algorithm of choice for multiple pattern search.
</p>

<p>
K patterns, in a large string s, find any one of the K patterns.
</p>
</div>

<div id="outline-container-orgd9a8c38" class="outline-5">
<h5 id="orgd9a8c38"><span class="section-number-5">12.4.3.1</span> Rolling Hash</h5>
<div class="outline-text-5" id="text-12-4-3-1">
</div>
<ol class="org-ol">
<li><a id="orgcdf567b"></a>Rabin-Karp rolling hash<br /></li>

<li><a id="orgcb02881"></a>Cyclic Polynomial (Buzhash)<br />
<div class="outline-text-6" id="text-12-4-3-1-2">
<p>
<code>s(a)</code> means shift a left.
</p>

\begin{equation}
H=s^{k-1}(h(c_1)) \oplus s^{k-2}(h(c_2)) \oplus \ldots \oplus s(h(c_{k-1})) \oplus h(c_k)
\end{equation}

<p>
<code>h</code> is a tabulation hashing.
</p>

<p>
To remove \(c_1\) and add \(c_{k+1}\):
</p>

\begin{equation}
H = s(H) \oplus s^k(h(c_1)) \oplus h(c_{k+1})
\end{equation}
</div>
</li>
</ol>
</div>

<div id="outline-container-orga1226ab" class="outline-5">
<h5 id="orga1226ab"><span class="section-number-5">12.4.3.2</span> Tabulation hashing</h5>
<div class="outline-text-5" id="text-12-4-3-2">
<p>
input key is <code>p</code> bits, output is <code>q</code> bits.
choose a <code>r</code> less then <code>p</code>, and \(t=\lceil p/r \rceil\).
</p>

<p>
view a key as t r-bit numbers. Use a lookup table filled with random values
to compute hash value for each of t numbers. Xor them together.
</p>

<p>
The choice of r should be made in such a way that this table is not too large,
so that it fits into the computer's cache memory.
</p>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
